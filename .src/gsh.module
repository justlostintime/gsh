' Gambas module file

Export
'Fast Unsafe
Public DataTypes As String[] = ["Binary", "Boolean", "Byte", "Short", "Integer", "Long", "Single", "Float", "Date", "String", 
                                       "LongDate", "Pointer", "Variant", "Function", "Class", "NULL", "Object", "Not Array", "", 
                                       "", "", "", "", ""]
Public TypeToText As String[] = ["BackGround", "Normal", "KeyWord", "Function", "Operator",
                                 "Symbol", "Number", "String", "Comment", "BreakPoint", "CurrentLine",
                                 "DataType", "", "HighLight", "", "Error", "Help", "PreProcessor", "Escape", "Label", 
                                  "Constant", "Alternate", "Custom1", "", "", "", "", "", "", "", ""]

''Why are repeat and do in this list..?
Public LocalKeyWords As String[] = ["include", "use", "help", "edit", "lambda", "begin", "run", "alias", "list", "repeat", "do", "fast", "unsafe", "compile", "get"]

Public ConsoleHighlight As New ConsoleHighlight
Public ReadQueue As New Queue     ' Used to push items to be read first

Public ExecBuffer As String = ""
Public LambdaBuffer As String = ""
Public InLambda As Boolean = False
Public LambdaLevel As Integer = 0
Public FunctionLevel As Integer = 0
Public CompileScript As String = ""
Public CompileOnly As Boolean = False
Public InBuffer As String
Public NoPreProcess As Boolean = False
Public NoLinkCheck As Boolean = False
Public CommandMode As Boolean = True
Public InLineCommand As String = ""
Public VarCommandSource As String = ""
Public LocalFunRun As String = ""
Public cmdLineParameters As String[]
'\\033[2K - Clear Line"
'\\033[K Erase to end of line"
'use \x01  to start escapes that will not be counted as part of the length of the prompt
'use \x02  to end the  uncounted charaters
Public Const DefaultPrompt As String = "\"\\x01\\x1b[31m\\x02\" & application.id & \".\" & user.name & \"@\" & system.host & \":\\x01\\x1b[32m\\x02\" & env[\"PWD\"] & \"\\x01\\x1b[0m\\x1b[0K\\x02 > \"" 
Public DefaultHelp As String[] = [System.find("less"), "-c"]

Public BlockLevel As Integer = 0
Public BlockIndent As String = "\x00"

Public InBufParse As String[]
Public SymbolTable As New Collection
Public ContainsGlobal As Boolean = False

Public History As New Collection
Public HCurrentRead As Integer = -1
Private ReadLineVersion As Integer = -1

Public PreOutBuf As New Collection
Public BlockSize As Integer = 4512000
Public CollectMemLen As Integer = 1512000
Public AppSource As File = File.in
Public LinkTable As New Collection
Public UseTable As New String[]
Public ExternTable As New String[]
Public StructTable As New String[]
Public CompilerDirectiveTable As New String[]

Public bCleanup As Boolean = False
Public bN As Boolean = False 
Public bSingleUse As Boolean = False 
Public bH As Boolean = False                                 'display the manual
Public bDbaseServer As Boolean = False                       'Run as a service
Public bInteractive As Boolean = False                       'Force the interface to be interactive
Public bLogon As Boolean = False                             'Force to act as logon shell
Public sPortNumber As String = ""                            'Port number/name to read and write to in service mode

Public Source As String = "STDIN"
Public DefaultSharedMem As String = user.name & "gsh"
Public DefaultImageName As String = "gsh.image"

Private RunningProcess As Process = Null
Private RunningProcessStart As Date
Private AutoCompile As Boolean = True
Private LocalRunning As Boolean = False
Private gshrcdate As Date = Now
Private onstartrcdate As Date = Now
Private onexitrcdate As Date = Now


' Extern rWrite(handle As Integer, data As Pointer, len As Integer) As Integer In "libc:6" Exec "write"
' Extern setenv(name As String, value As String, overwrite As Integer) As Integer In "libc:6"
' Extern unsetenv(name As String) As Integer In "libc:6"
' Extern putenv(name As String) As Integer In "libc:6"
' Extern getenv(name As String) As Pointer In "libc:6"

Extern c9_readline(prompt As String) As Pointer In "libreadline:9" Exec "readline"
Extern c9_add_history(Item As String) In "libreadline:9" Exec "add_history"
Extern c8_readline(prompt As String) As Pointer In "libreadline:8" Exec "readline"
Extern c8_add_history(Item As String) In "libreadline:8" Exec "add_history"
Extern c7_readline(prompt As String) As Pointer In "libreadline:7" Exec "readline"
Extern c7_add_history(Item As String) In "libreadline:7" Exec "add_history"
Extern c6_readline(prompt As String) As Pointer In "libreadline:6" Exec "readline"
Extern c6_add_history(Item As String) In "libreadline:6" Exec "add_history"
Extern c5_readline(prompt As String) As Pointer In "libreadline:5" Exec "readline"
Extern c5_add_history(Item As String) In "libreadline:5" Exec "add_history"


Extern rFree(Mem As Pointer) In "libc:6" Exec "free"
Extern chdir(Dest As String) As Integer In "libc:6"
Private windowwidth As Integer = 80
Private windowheight As Integer = 24


Public DoTrace As Boolean = False
Public TraceLevel As Integer = 1
Public jobctl As Boolean = False
Public ActiveProcesses As New Process[]

Private Sub DetectReadlineVersion() As Integer
 Dim v As Integer = 4
  Try c9_add_history("")
  If Not Error Then Return 9
  Try c8_add_history("")
  If Not Error Then Return 8
  Try c7_add_history("")
  If Not Error Then Return 7
  Try c6_add_history("")
  If Not Error Then Return 6
  Try c5_add_history("")
  If Not Error Then Return 5
  Return v
End


Public Sub settrace(setting As Boolean, Optional level As Integer = TraceLevel) ' this function turns on the compile tracing

  DoTrace = setting
  TraceLevel = level
  
End

Public Sub setjobctl(setting As Boolean)
  
  jobctl = setting
  
End


Public Sub application_signal(sig As Integer)
' Signal[Signal.sigtstp].Ignore
'   Signal[Signal.sigterm].catch
'   signal[Signal.SIGINT].catch
'   Signal[Signal.SIGHUP].catch  
  ' Print " Signal "; sig
  Select Case sig
    Case Signal.SIGWINCH
        If DoTrace Then Error (" Window was Resized to "); Env["LINES"]; " and "; Env["COLUMNS"]
        windowwidth = Env["COLUMNS"]
        windowheight = Env["LINES"]
        Return
        
    Case Signal.SIGHUP
       If RunningProcess <> Null Then
        Signal.send(RunningProcess.Handle, Signal.SigHup)
        Try gshlogging(User.home &/ "vars/gsh.log", "Process SigHup" & RunningProcess.handle)
        RunningProcess = Null
        Return 
      Endif
      Try gshlogging(User.home &/ "vars/gsh.log", "Process SigHup" & Application.id)
      ExitProgram()

    Case Signal.SIGTERM
       If RunningProcess <> Null Then
        Signal.send(RunningProcess.Handle, Signal.SigTerm)
        Try gshlogging(User.home &/ "vars/gsh.log", "Process SigTerm" & RunningProcess.handle)
        RunningProcess = Null
        Return 
      Endif
      
      ExitProgram()
      
    Case Signal.SIGINT
      If RunningProcess <> Null Then
        Signal.send(RunningProcess.Handle, Signal.SigInt)
        Try gshlogging(User.home &/ "vars/gsh.log", "Process SigInt" & RunningProcess.handle)
        RunningProcess = Null
        Error "\n"
        Return 
      Endif
      
      If LocalRunning Then 
        LocalRunning = False
        Error.Raise("Terminated")
      Endif
      Return
      
  End Select
  
End

Public Sub TestModuleAccess() As Boolean
  
  Return True
  
End

Public Sub _init()
  Component.Load("gb.signal")
  Class.Load("Signal")
  Class.Load("SubCls")
  Class.Load("CreateCmdProgram")
 
  SharedMem.DoInit()
  
End


Public Sub ProcessOptions() As String[]

   Dim bA, bR As Boolean
   Dim iT As Integer
   Dim sC As String[] 
   Dim sS, sI As String
   
   Args.Begin(Application.Name & " <option> <Command.gsh>")
   bDbaseServer = Args.Has("d", "service", ("Run shell as a service point"))
   sPortNumber = Args.Get("p", "port", ("I/O Port number/name to use else  Defaults to stdin/stdout/stderr"))
   bA = Args.Has("a", "about", ("Display About ") & Application.Name)
   bR = Args.Has("v", "version", ("Display version number"))
   iT = Args.GetInteger("t", "trace", ("Turn on tracing Parm s 0, off, 1 = user, 3 = -r and -f -4 = all"))
   sS = Args.Get("s", "shmname", ("Shared Memory Name for application"))
   bSingleUse = Args.has("S", "Single", ("Do not use shared memory"))
   bN = Args.Has("n", "noload", ("Do Not Load gsh Image - already loaded by another process"))
   sI = Args.Get("I", "image", ("Use this specific image when starting"))
   bInteractive = Args.Has("i", "interactive", ("Force Shell to be interactive"))
   bLogon = Args.Has("l", "logon", ("Start as a logon shell"))
   bH = Args.Has("m", "manual", ("Print the extended help infomation"))
   BlockSize = Args.GetInteger("M", "memsize", ("Defines the ammount of storage needed for the In Memory Database(default 4.5m)"), "<MemLength>", 4512000)
   CollectMemLen = Args.GetInteger("D", "disctsize", ("Size of in memory Database Dictionary and index(Default 1.5m)"), "<DictLength>", 1512000)
   bCleanup = Args.Has("C", "cleanup", ("Cleanup and delete the old Shm file if it is closed and left around"))
   InLineCommand = Args.Get("c", "command", ("Command to be executed"))
   VarCommandSource = Args.Get("f", "from", ("Execute the content of a global variable"))
   LocalFunRun = Args.Get("r", "runline", ("Execute the following command line"))
   sC = Args.End()
   
   If ba Then 
      Print ("\n\nGambas Shell")
      Print ("Interactive console for using gambas as your day to day shell")
      Print ("It Is Also usefull For learning To program")
      Print ("Try simple things interactively")
      Print ("It is also a powerful shell for writing appliction that must share variables between tasks")
      Print ("You may extend the image by creating built in commands as gambas functions and classes")
      Print ("  that will be shared by every running instance of the shell in real time")
      Print ("westwood : https://github.com/justlostintime/GambasShell/wiki\n\n")
      Quit 0
   Endif
   
   If br Then 
       Print ("Rev:") & Application.Version
       Quit 0
   Endif
   
   TraceLevel = iT
   
   If TraceLevel > 3 Then DoTrace = True
   
   If bDbaseServer Then Error ("GSH in service mode");; Now;; Application.Version
   
   If sS <> "" Then
        DefaultSharedMem = ss
   Endif
   
   If si <> "" Then
      If File.Dir(si) = "" Then si = sharedmem.DefaultSaveLocation & si
      
      If Exist(si) Then
         DefaultImageName = si
      Endif
      
   Endif
   
  Return sC
  
End

Public Sub RunFromExtern(ScriptName As String, ...)
  execbuffer = ""
  Try RunScript(ScriptName)
  If Error Then
    Error (" extern run "); Error.text; Error.where
  Endif
  execbuffer = ""
  
End


Public Sub RunScript(cmd As String) As Boolean
   Dim oldCommandMode As Boolean = CommandMode
   Dim OldSource As String = Source
   Dim oldAppSource As File = AppSource
   cmd = Replace(cmd, "\"", "")
   Dim fPath As String = cmd
   
  If File.Dir(fPath) = "" Then 
      fPath = User.home &/ "vars" &/ cmd
      If Not Exist(fpath) Then 
            fpath = System.Find(cmd)
            If IsNull(fPath) Then Return False
      Endif
  Endif
   
   CommandMode = True
   Source = "FILE"

   Try AppSource = Open fpath For Read
      If Error Then
        Error ("Error : Gsh script: "); cmd; " -  "; Error.text
        appSource = oldAppSource
        Source = OldSource
        CommandMode = OldCommandMode
        Return False
      Else
          While IfReader(["QUIT"])
            ProcessProg()
            Wait
          Wend
      Endif
      
      Close AppSource
      
      appSource = oldAppSource
      Source = OldSource
      CommandMode = OldCommandMode
      Return True
End


Public Sub GetSub(cmd As String) As Boolean
  Dim fpath As String
  cmd = Replace(cmd, "\"", "")
  
  Dim SubName As String = "sub." & File.Name(Lower(cmd))
  If SharedMem.exist(SubName) Then Return True
  
  fpath = cmd
  If File.Dir(fPath) = "" Then 
      fpath = User.home &/ "vars/subs" &/ cmd
      If Not Exist(fPath) Then 
          fpath = "/usr/share/gsh/subs" &/ cmd
          If Not Exist(fPath) Then
              Error.Raise(("Get Error: Command not found ") & cmd)
              Return False
          Endif
      Endif
  Else 
    If Not Exist(fPath) Then
       Error.Raise(("Get Error: Command not found ") & cmd)
       Return False
    Endif
  Endif
  
  SharedMem[SubName] = File.Load(fPath)
  
  'If IsNull(SubCls.CompileIt(SubName, SharedMem[subname])) Then Return False
  If Not compile(SubName) Then Return False
  Return True  
End


Private Sub SetDefaults()

With sharedmem
  
 If Not .exist("$profile") Then .["$profile"] = False
 If Not .exist("$alias") Then .["$alias"] = New Collection
 If Not .exist("$blockindent") Or If .["$blockindent"] = "" Then .["$blockindent"] = "  "   ' this is the block indent characters for entering blocks of code
 If Not .exist("$execprog") Then .["$execprog"] = "print \"Gambas Shell \""
 If Not .exist("$prompt") Then .["$prompt"] = DefaultPrompt
 If Not .exist("$result") Then .["$result"] = "OK"
 If Not .exist("$maxhistory") Then .["$maxhistory"] = 300        ' define the max history length
 If Not .exist("$historycurrent") Then .["$historycurrent"] = 0  ' defines the current history level
 If Not .exist("$history") Then .["$history"] = New Collection
 If Not .exist("$editor") Then .["$editor"] = "/bin/nano"
 If Not .exist("$hexeditor") Then .["$hexeditor"] = "/usr/bin/hexedit"
 If Not .exist("$helpdisplay") Then .["$helpdisplay"] = DefaultHelp
 If Not .exist("$home") Then .["$home"] = user.home
 If Not .exist("$hosttype") Then .["$hosttype"] = system.Architecture
 If Not .exist("$hosthame") Then .["$hostname"] = system.host
 If Not .exist("$term") Then .["$term"] = "xterm-256color"
 If Not .exist("newprofile") Then .["newprofile"] = False
 If Not .exist("$path") Then .["$path"] = User.home &/ ".local/bin:" & User.home &/ "bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games"
 If Not .exist("$env") Then .["$env"] = ["PWD=" & .["$pwd"], "PATH=" & .["$path"], "HOME=" & .["$home"], "TERM=" & .["$term"], "HOSTTYPE=" & .["$hosttype"], "HOSTHAME=" & .["$hostname"], "LASTPLACEONEARTH=EndOfTheEarth"]
 'If Not .exist("$pwd") Then .["$pwd"] = Env["PWD"]
 
 If bLogon Then Env["PATH"] = SharedMem["$path"]
 
 .["$pwd"] = Env["PWD"]
 
 If .["$pwd"] = "" Then
   Env["PWD"] = User.Home
   .["$pwd"] = Env["PWD"]
 Endif
 
 .["$baseenv"] = ["PWD=" & .["$pwd"], "PATH=" & .["$path"], "HOME=" & .["$home"], "TERM=" & .["$term"], "HOSTTYPE=" & .["$hosttype"], "HOSTHAME=" & .["$hostname"], "LASTPLACEONEARTH=EndOfTheEarth"]

 ' If Not .exist("jobctl") Then .["jobctl"] = False
 
 If Not .["$profile"] Then
   Try RunScript(User.home &/ "vars/profile.gsh")
   If Error Then
        Error "Compile On Start of profile.gsh Failed :"; Error.text
   Endif
   execbuffer = ""
   .["$profile"] = True
 Endif
 
 .Sync(".", DefaultImageName)
 
End With 
End



Private Sub UpdateEnv()
  getenv()
End

Public Sub getenv() As String[]
  
  SharedMem["$pwd"] = Env["PWD"]

  Dim senv As New String[]
  For Each s As String In Application.env
    senv.add(s & "=" & Application.Env[s])
  Next
  SharedMem["$env"] = senv
  Return senv
  
End


Public Sub compileClassOnStart()
  Dim Syms As String[] = SharedMem.Variables("class.*")
  
  For Each sym As String In syms
      'Print "On Start Class Compile "; sym
      Try compile(sym)
      If Error Then
        Error ("Compile On Start of Class");; sym;; ("Failed :");; Error.text;; Error.where
      Endif
  Next
  
  linktable.Clear()
End


Public Sub compileFunctionsOnStart()
  
  Dim Syms As String[] = SharedMem.Variables("sub.*")
 
  For Each sym As String In syms
      'Print "On Start Function Compile "; sym
      Try compile(sym)
      If Error Then
        Error ("Compile On Start of Sub/Func/Proc");; sym;; ("Failed :");; Error.text;; Error.where
      Endif
  Next
  linktable.Clear()
End

Private Sub CompileBuffer(sym As String, buffer As String, Optional componly As Boolean = False) As Boolean
  Dim proc As String = ""
  Dim FinalProgram As String = ""
  Dim ExtraClasses As New Collection
  
      proc = PreProcBuffer(buffer)
      If IsNull(proc) Then Return False
      
        Dim AlreadyLinked As New String[]
        
  		  Dim ProcLinks As String = ""
  
  		  While LinkTable.COUNT
          If linktable.first <> sym Then
            If Not AlreadyLinked.Exist(LinkTable.First) Then
                AlreadyLinked.Add(LinkTable.first)
                If RegExp.Match(linktable[linktable.first], "^class .*", RegExp.Caseless) Then
                  ExtraClasses.add(PreProcBuffer(linktable[linktable.first]), Split(linktable.first, ".")[1])
                Else
  		            ProcLinks &= PreProcBuffer(linktable[linktable.first])
                Endif
            Endif
          Endif 
          linktable.Remove(linktable.first)
        Wend
        
        For Each sinsert As String In CompilerDirectiveTable
          FinalProgram &= sInsert & "\n"
        Next
        
        For Each sinsert As String In StructTable
          FinalProgram &= sInsert & "\n"
        Next
        
  		  For Each sinsert In ExternTable
          FinalProgram &= sInsert & "\n"
        Next

  		  FinalProgram &= proclinks & proc
  
        Linktable.clear()
        CompilerDirectiveTable.Clear()
        StructTable.Clear()
  		  ExternTable.Clear()
  
        SubCls.CompileIt(Lower(sym), FinalProgram, componly, ExtraClasses)
          
        UseTable.Clear()
        
        Return True
      'Endif
      
      linktable.Clear()
      Return False
  
End
Private Sub CreateProject(sym As String, buffer As String, Optional componly As Boolean = False, ExecuteProject As Boolean = False) As String
  Dim proc As String = ""
  Dim FinalProgram As String = ""
  Dim ExtraClasses As New Collection
  Dim ProjectDirectory As String
  
  
      proc = PreProcBuffer("Public Sub main()\n" & buffer & "\nend\n") 
      If IsNull(proc) Then Return ""
        Dim AlreadyLinked As New String[]
  		  Dim ProcLinks As String = ""
  
  		  While LinkTable.COUNT
          If linktable.first <> sym Then
            If Not AlreadyLinked.Exist(LinkTable.First) Then
                AlreadyLinked.Add(LinkTable.first)
                If RegExp.Match(linktable[linktable.first], "^class .*", RegExp.Caseless) Then
                  ExtraClasses.add(PreProcBuffer(linktable[linktable.first]), Split(linktable.first, ".")[1])
                Else
  		           ProcLinks &= PreProcBuffer(linktable[linktable.first])
                Endif
            Endif
          Endif 
          linktable.Remove(linktable.first)
        Wend
        
        For Each sinsert As String In CompilerDirectiveTable
          FinalProgram &= sInsert & "\n"
        Next
        
        For Each sinsert As String In StructTable
          FinalProgram &= sInsert & "\n"
        Next
        
  		  For Each sinsert In ExternTable
          FinalProgram &= sInsert & "\n"
        Next
        
        FinalProgram = FinalProgram & ProcLinks & proc
        ProjectDirectory = SubCls.CompileIt(Lower("sub." & sym), FinalProgram, componly, ExtraClasses, ExecuteProject)
        
        CompilerDirectiveTable.Clear()
        StructTable.Clear()
  		  ExternTable.Clear()
        Linktable.Clear()
        UseTable.Clear()
        Return ProjectDirectory
End


Private Sub Compile(sym As String, Optional componly As Boolean = False) As Boolean
  Dim proc As String = SharedMem[Lower(sym)]
      Dim result As Boolean
      
      Dim saveDiective As String[] = CompilerDirectiveTable
      Dim saveLinks As Collection = linktable
      Dim saveuse As String[] = UseTable
      Dim saveextern As String[] = ExternTable
      Dim SaveStruct As String[] = StructTable
      'Print "Compile prog : "; sym
      
      LinkTable = New Collection
      UseTable = New String[]
      ExternTable = New String[]
      StructTable = New String[]
      CompilerDirectiveTable = New String[]
      
      result = CompileBuffer(sym, proc, componly)
      
      linktable = saveLinks
      usetable = saveuse
      externtable = saveextern
      structtable = savestruct
      CompilerDirectiveTable = saveDiective
      Return result
End

Private Sub VerifyAppDepend()

If Not Exist(User.home &/ "vars") Then
  Mkdir User.Home &/ "vars"
Endif

If Not Exist(User.home &/ "bin") Then
  Mkdir User.Home &/ "bin"
Endif
  
 If Not Exist(User.home &/ "vars/class") Then
  Mkdir User.Home &/ "vars/class"
Endif
If Not Exist(User.home &/ "vars/subs") Then
  Mkdir User.Home &/ "vars/subs"
Endif
If Not Exist(User.home &/ "vars/struct") Then
  Mkdir User.Home &/ "vars/struct"
Endif

If Not Exist(User.home &/ "vars/gsh.rc") Then
  Shell "touch " & User.home &/ "vars/gsh.rc" Wait
Endif

If Not Exist(User.home &/ "vars/subs/onstart") Then
  Copy "/usr/share/gsh/subs/onstart" To User.home &/ "vars/subs/onstart"
Endif
If Not Exist(User.home &/ "vars/subs/onexit") Then
  Copy "/usr/share/gsh/subs/onexit" To User.home &/ "vars/subs/onexit"
Endif

If Not Exist(User.home &/ "vars/profile.gsh")
   Copy "/usr/share/gsh/profiles/profile.gsh" To User.home &/ "vars/profile.gsh"
   Chmod User.home &/ "vars/profile.gsh" To "rwxr-x---"
Else
   If Stat("/usr/share/gsh/profiles/profile.gsh").lastmodified > Stat(User.home &/ "vars/profile.gsh").lastmodified Then
     If Exist(User.home &/ "vars/profile.gsh.new") Then Kill User.home &/ "vars/profile.gsh.new"
     Copy "/usr/share/gsh/profiles/profile.gsh" To User.home &/ "vars/profile.gsh.new" 
     Chmod User.home &/ "vars/profile.gsh.new" To "rwxr-x---"
   Endif
Endif

  
End

Private Sub add_history(data As String)
   If readlineversion = -1 Then 
      readlineversion = DetectReadlineVersion()
      SharedMem["readlineversion"] = readlineversion
   Endif
   Select Case ReadLineVersion
      Case 9
        c9_add_history(data)
      Case 8
        c8_add_history(data)
      Case 7
        c7_add_history(data)
      Case 6
        c6_add_history(data)
      Case 5
        c5_add_history(data)
    End Select
End


Public Sub gshlogging(logname As String, msg As String)
  
  Dim sfile As File
  Try sfile = Open logname For Write Append
  If Error Then
    Error "Unable to open log file "; logname
  Endif
  Print #sfile, Format(Now, "yyyy/mm/dd hh:nn:ss.uu");; msg
  Close sfile

End

Public Sub Main()
Dim DontExit As Boolean
Dim i As Integer

'System.Language = "fr_FR"
'System.Language = "en_US"
cmdLineParameters = ProcessOptions()

VerifyAppDepend()

Try gshlogging(User.home &/ "vars/gsh.log", Args.all.Join(" "))
 
 If bSingleUse Then
    SharedMem.CollectMemLen = CollectMemLen
    SharedMem.Begin(BlockSize) ' preset this to be 4.5 meg of memory
    'Debug "Opening in single use/user mode. Image will not be updated"
 Else 
    If Exist("/dev/shm/" &/ DefaultSharedMem) Then bN = True ' if the shared memory already exists as a file then just use it
    SharedMem.CollectMemLen = CollectMemLen
    SharedMem.BeginNamed(DefaultSharedMem, BlockSize, bCleanup) ' preset this to be 4.5 meg of memory
 Endif

 Dim ImageFile As String = SharedMem.DefaultSaveLocation & DefaultImageName
 
 If Not bN And Exist(ImageFile) Then
      SharedMem.Merge(DefaultImageName)
 Endif 
 
  SharedMem["$pwd"] = Env["PWD"]
  SetDefaults()
  
  Class.Load("SubCls")
  Class.Load("CreateCmdProgram")
  Class.Load("Parser")
  Class.Load("ServiceMode")
  
  gshrcdate = Stat(User.home &/ "vars/gsh.rc").lastmodified
  If Not SharedMem.exist("gshrcdate") Then SharedMem["gshrcdate"] = ""
  If SharedMem["gshrcdate"] < datetostring(gshrcdate) Then
    SharedMem["gshrcdate"] = datetostring(gshrcdate)
    If Not bDbaseserver Then Error ("Loading updated gsh.rc")
    Try RunScript(User.home &/ "vars/gsh.rc")
    If Error Then
      Error ("Unable to run updated gsh.rc :");; Error.text
    Endif
    execbuffer = ""
  Endif
  
  
  Try chdir(Env["PWD"])
  CreateCmdProgram.InitAlias()
  
  'If VarCommandSource = "" Then
    If DoTrace Then Error "(Trace "; Now; ") "; ("Compile Classes and Funtions in image at startup")
    compileClassOnStart()
    compileFunctionsOnStart()
    If DoTrace Then Error "(Trace "; Now; ") "; ("Compile Classes and Funtions in image at startup complete")
  'Endif
  
  If bH Then 
      Try PrintHelp()
      If Error Then Error Error.text
      ExitProgram(0)
  Endif
  
  UpdateEnv()
  
  Signal[Signal.sigtstp].Ignore
  Signal[Signal.sigterm].catch
  signal[Signal.SIGINT].catch
  Signal[Signal.SIGHUP].catch
  Signal[Signal.SIGWINCH].catch

  ' Check if we have a one line command
  ' Posix says we must execute this command then exit
  ' we provide the environment for this execution in our shell
   If TraceLevel > 2 Then DoTrace = True
    
  'Check if we have request to execute a local function

  If LocalFunRun <> "" Then
    
    If DoTrace Then Error "(Trace "; Now; ") "; (" Execute a function in image "); LocalFunRun
    execBuffer = LocalFunRun
    For i As Integer = 0 To cmdLineParameters.Max
      cmdLineParameters[i] = Quote(cmdLineParameters[i])
    Next
    execBuffer &= " " & cmdLineParameters.Join(" ")
    ExecBuffer = preprocesses(execbuffer) & "\n"
    Try ProcessProg()
    If Error Then 
       Error Error.text
       ExitProgram(1)
    Endif
    ExitProgram()
  Endif
  
  'Check for a request to execute a variable
  If VarCommandSource <> "" Then
    
    If DoTrace Then Error "(Trace "; Now; ") ";; ("Execute The Content of a variable from shared memory ");; VarCommandSource
    
    If SharedMem.exist(VarCommandSource) Then
        Dim codebuffer As String = "Lambda"
        
        If cmdLineParameters.count > 0 Then
          For i As Integer = 0 To cmdLineParameters.Max
              cmdLineParameters[i] = Quote(cmdLineParameters[i])
          Next
          codebuffer &= "("
          For i = 0 To cmdLineParameters.max
             codebuffer &= cmdLineParameters[i]
             If i < cmdLineParameters.max Then codebuffer &= ","
          Next
          codebuffer &= ")"
        Endif
        
         codebuffer &= "\n" & SharedMem[VarCommandSource] & "\nend\n"
         If DoTrace Then Print "(Trace "; Now; ") ";; ("***********************************\nVariable program call defined as \n ");; codebuffer;; "\n*********************\n"
         OpenBuffer(codebuffer)
         While IfReader(["QUIT"])
                Try ProcessProg()
                If Error Then 
                     Error Error.text
                     ExitProgram(1)
                Endif
                Wait
          Wend
    Else
         Error ("Execute from Global Variable : Variable \""); VarCommandSource; ("\" Not Found")
         ExitProgram(1)
    Endif
    
    ExitProgram()
    
  Endif
  
  'check for an -c command to execute
  If InLineCommand <> "" Then                 ' we have a command -c 
      If DoTrace Then Error "(Trace "; Now; ") ";; ("-c Command recieved :["); InLineCommand; "]"
      Dim MyProcess As Process
      Try MyProcess = Shell InLineCommand Wait
      If Error Then Error Error.text
      ExitProgram(Process.LastValue)
  Endif

' Check for a list of script files on the command line
  If cmdLineParameters.count > 0 And If cmdLineParameters[0][0] <> "-" Then
    If DoTrace Then Error "(Trace "; Now; ") ";; ("Command line scripts to execute cnt="); cmdLineParameters.count
    CommandMode = True
    Source = "FILE"
    Dim runcmder As String = cmdLineParameters[0]
    
      If DoTrace Then Error "(Trace "; Now; ") ";; ("Execite gsh script file");; runcmder
      Try AppSource = Open runcmder For Read
      If Error Then
        Error "Gsh script not found : "; runcmder
        ExitProgram(1)
      Endif
      
      While IfReader(["QUIT"])
       Try ProcessProg()
       If Error Then 
          Error Error.text
          Break
       Endif
       Wait
      Wend
      
      Close AppSource
      ExitProgram()
  Endif
If TraceLevel > 0 Then DoTrace = True
' Then assume it is an interactive session
If Not bDbaseServer Then ' dont do this if in service mode

  onstartrcdate = Stat(User.home &/ "vars/subs/onstart").lastmodified
  If Not SharedMem.exist("onstartrcdate") Then SharedMem["onstartrcdate"] = ""
  If SharedMem["onstartrcdate"] < datetostring(onstartrcdate) Or If Not SharedMem.exist("sub.onstart") Then
    SharedMem["onstartrcdate"] = datetostring(onstartrcdate)
    Try SharedMem["sub.onstart"] = File.load(User.home &/ "vars/subs/onstart")
    If Error Then
      Error ("Unable to load onstart ;");; Error.text
    Endif
    execbuffer = ""
  Endif
  
  onexitrcdate = Stat(User.home &/ "vars/subs/onexit").lastmodified
  If Not SharedMem.exist("onexitrcdate") Then SharedMem["onexitrcdate"] = ""
  If SharedMem["onexitrcdate"] < datetostring(onstartrcdate) Or If Not SharedMem.exist("sub.onexit") Then
    SharedMem["onexitrcdate"] = datetostring(onstartrcdate)
    Try SharedMem["sub.onexit"] = File.load(User.home &/ "vars/subs/onexit")
    If Error Then
      Error ("Unable to load onexit :");; Error.text
    Endif
    execbuffer = ""
  Endif
  
  If SharedMem.exist("$history") Then
      history = SharedMem["$history"]
      If history.count > 0 Then 
         SharedMem["$historycurrent"] = CInteger(history.Last)
      Else
         SharedMem["$historycurrent"] = 1
      Endif
  Endif
  
  SetTitle()
  
  For Each sh As String In history
        add_history(sh & "\x00")
  Next
  
  execlocal(["onstart()"])                                                  ' only if we are not a service


  If Exist(User.home &/ "vars/profile.gsh.new") And If SharedMem["newprofile"] = False Then 
    Error ("New base Profile revision profile.gsh\nRun update to use new base profile\n\n")
    SharedMem["newprofile"] = True
  Else
    SharedMem["newprofile"] = False
  Endif
  
Else If sPortNumber <> ""                                                                       ' If we are a server then do this config
    CommandMode = True
    Source = "FILE"
    
      If DoTrace Then Error "(Trace "; Now; ") ";; ("Execite gsh script file");; runcmder
      Try AppSource = ServiceMode.InitService(sPortNumber)
      If Error Then
        Error "Gsh script not found : "; runcmder
        ExitProgram(1)
      Endif
      
      While IfReader(["QUIT"])
       Try ProcessProg()
       If Error Then 
          Error Error.text
          Break
       Endif
       Wait
      Wend
      
      Close AppSource
      ExitProgram()
  Endif

If DoTrace Then Error "(Trace "; Now; ") ";; ("Enter interactive mode!")
Dim InteractiveErrorCount As Integer = 0 
interactive: 

    While True
       Try DontExit = IfReader(["QUIT"])
       If Error Then
          Error Error.text  ' ;; "(" & Error.where & ")"
          CleanUpError()
       Else
          If Not DontExit Then Break
          Try ProcessProg()
          If Error Then 
              Error Error.text   ' ;; "(" & Error.where & ")"
              If DoTrace Then Error execBuffer
              CleanUpError()
          Else
              InteractiveErrorCount = 0
          Endif
       Endif
       
       If Not bDbaseServer Then settitle()
       
       Try chdir(Env["PWD"])
       If Error Then Error Error.Text
       
       Wait
       
    Wend
   
   If Not bDbaseServer Then execlocal(["onexit()"])
   
   ExitProgram()
 
  Catch
      Dim errorText As String = Error.text & ";" & Error.where
      Try gshlogging(User.home &/ "vars/gsh.log", "GSH Aborted with " & errorText & "(" & Error.where & ")")
     
      If LocalFunRun <> "" Or If VarCommandSource <> "" Then 
        
       ExitProgram(1)
       
      Endif
    
    CleanupError()
    Inc InteractiveErrorCount
    
    If InteractiveErrorCount > 1000 Then Quit 2
    
    Goto interactive
    
End

Private Sub CleanUpError()
  
    ExecBuffer = ""
    ReturnOutputTo = ""
    BlockIndent = "  "
    BlockLevel = 0
    
    LinkTable.clear()
    ExternTable.Clear()
    UseTable.Clear()
    StructTable.Clear()
    CompilerDirectiveTable.Clear()
    
    ContainsGlobal = False
    Error.Clear()
  
End

Private Sub ExitProgram(Optional ExitValue As Integer = 0)
  
        If bSingleUse Then 
          Try SharedMem.end()
          If Error Then Error Error.text
        Else
          Try SharedMem.End(DefaultImageName)
          If Error Then Error Error.text
        Endif
        
  Quit ExitValue
  
End

Public Sub datetostring(mDate As Date) As String
  Dim d As String = Format(mdate, "yyyymmddhhnnssuu")
  Return d
End

Public Sub SetTitle()
  
  Print "\x1b]0;gsh " & Application.Version & "-" & User.name & "@" & System.host & ":" & Env["PWD"] & "\x07";
  Flush
  
End


Public Sub ExecLocal(prog As String[]) As Boolean
  
  If prog.count <> 1 Then Return False
  
  Dim lsplit As String[] = Split(prog[0], "(,)", "\"\"", True, True)
  
  If lsplit.count < 1 Then Return False
  
  Dim method As String = lsplit[0]
  Dim sObject As String = "sub." & method
  
  
  If Not SubCls.Exist(sObject) Then Return False                  ' its not in the compiled list
  If SubCls.changed(sObject) Then Return False                    ' we changed it in this session so will reflect this after start
                                                                  ' In the mean time we will execute this as a script until its reloaded
                                                                  ' Can only load a function once after start
  If LinkTable.count > 1 Then Return False                        ' If this is not a self contained command then we can not run local
  If UseTable.count > 0 Then Return False                         ' If this command has any kind of use parameters we can not process
                                                                  ' Link Table will always have link to own code 
  linktable.Clear()
  Dim newsplit As String = RegExp.Replace(prog[0], "^.*[(]", "")
  newsplit = RegExp.Replace(newsplit, "[)]$", "")
  lsplit = Split(newsplit, ",", "[]()\n", True, True)
  Dim parms As New Variant[]
  For Each s As String In lsplit
    If s.len > 1 And If s[0] = "." Then 
      If s.len > 2 And If s[1] = "[" Then
        s = "sharedmem" & Mid(s, 2)
      Else
         s = "sharedmem" & s
      Endif 
    Endif
    If s <> "" Then parms.Add(Eval(s))
  Next
  
  If DoTrace Then 
       Error "(Trace "; Now; ") "; ("Exec local Sub/func/proc"); ": "; method
       For Each xs As Variant In parms
         Error "(Trace "; Now; ") "; "Exec Sub/proc/func parm"; ": "; xs
       Next
  Endif
  
  LocalRunning = True
  Try Object.Call(SubCls[sObject], method, parms)
  If Error Then
   LocalRunning = False
   If Error.text <> "Terminated" Then 
      Error (("Local Execute error in :") & prog[0] & Error.where & " @line(" & Split(Error.where, ".")[2] & ") [" & Error.text & "]")
      SubCls.doListing(SharedMem["sub." & method], Split(Error.where, ".")[2])
       Error.Raise(("Local Execute error in :") & prog[0] & " @line(" & Split(Error.where, ".")[2] & ") [" & Error.text & "]")
   Else
     Error ("[Terminated]")
   Endif
  Endif
  
  LocalRunning = False
  Return True
  
  Catch
    Error.Propagate()
End

Public ReturnOutputTo As String = ""
Public Sub _unknown(...)
  
  Error ("GSH Call to Unknown function");; Param.name
  
End


Public Sub ProcessProg(Optional NoWait As Boolean = False)
  'Dim ProgramCommand, Result As String
  Dim MyProg As File
  Dim MyProcess As Process
  Dim Program As String = ""
  Dim ProgPart1 As String = ""
  Dim AlreadyLinked As String[]
  'Dim prop As String
  Dim sInsert As String
 ' Dim ProjectDirectory As String
  Dim eCmd As String[]
  Dim execline As String
  Dim StartCopy As Integer
  Dim EndCopy As Integer
  Dim cmdjobsinfo As String
'  Dim Result As String
  
  ''Debug "Execute the program"
  
  If Trim(ExecBuffer) = "" Then Return
  If Right(ExecBuffer, 2) = "&\n" Then
    NoWait = True
    execbuffer = Replace(execbuffer, "&\n", "\n")
  Endif
  
  SharedMem["$execprog"] = ExecBuffer
  
  If Not nowait Then
    If execlocal(Split(execbuffer, "\n", "\"\"", True, True)) Then 
       ExecBuffer = ""
       ContainsGlobal = False
       Return 
    Endif
  Endif
  
  ' If Not compileonly Then ' we are going to run this with gbx3 not as a script
  '                         ' otherwise we will just do the ussual
  '                         
  '    ProjectDirectory = CreateProject(User.name & Rand(0, 99999), ExecBuffer, False, True)  
  '    If ProjectDirectory <> "" Then
  '      eCmd = ["/usr/bin/gbx3", ProjectDirectory]
  '             'If DoTrace Then ecmd.Add("-t", 1)
  '             eCmd.Insert(cmdLineParameters)
  '             If nowait Then
  '               Try MyProcess = Exec ecmd With getenv() 'As "SysProc"
  '               If Error Then 
  '                   Error Error.text
  '                   ExecBuffer = ""
  '                   ReturnOutputTo = ""
  '                   LinkTable.clear()
  '                   ContainsGlobal = False
  '                   Return 
  '               Endif
  '               
  '               If MyProcess <> Null And If jobctl Then
  '                   ActiveProcesses.Add(MyProcess)
  '                   execline = Split(execbuffer, "\n", "", True)[0]
  '                   StartCopy = InStr(execline, "EXEC [", 0, gb.IgnoreCase)
  '                   If StartCopy > 0 Then Startcopy += 6 ' len of search string
  '                   EndCopy = InStr(execline, "] with", 0, gb.ignorecase)
  '                   If Endcopy > 0 Then
  '                       cmdjobsinfo = Mid(execline, StartCopy, endcopy - startcopy)
  '                   Else 
  '                       cmdjobsinfo = execline
  '                   Endif
  '                   sharedmem["pid.p" & MyProcess.id & Application.id] = Str(MyProcess.id) & "|" & Format(Now, "mm/dd/yyyy hh:nn:ss.uu") & "|" & cmdjobsinfo & "\n"
  '                   
  '                 '"sharedmem[\"pid.p\" & mProc" & BaseName & Str(i) & ".id]= str(mProc" & BaseName & Str(i) & ".id)&\"|\"& format(now,\"mm/dd/yyyy hh:nn:ss.uu\")& \"|\" & " & cmdjobsinfo & "\n"
  '               Endif
  '             Else
  '               Try MyProcess = Exec ecmd With getenv() ' As "SysProc"
  '               If Not Error Then 
  '                 RunningProcess = MyProcess
  '                 If jobctl Then RunningProcessStart = Now
  '                 MyProcess.Wait()
  '                 If jobctl Then
  '                   Error "Start="; Format(RunningProcessStart, "mm/dd/yyyy hh:nn:ss.uu"), "End="; Format(Now, "mm/dd/yyyy hh:nn:ss.uu"), "Duration="; (Now - RunningProcessStart) * 100000
  '                 Endif
  '                 RunningProcess = Null
  '               Endif
  '             Endif
  '      
  '     Else
  '       Error "Project directory is invalid"
  '     Endif
  '     
  '     ExecBuffer = ""
  '     ReturnOutputTo = ""
  '     LinkTable.clear()
  '     ContainsGlobal = False
  '    Return
  ' Endif
  
  ContainsGlobal = True ' force to use always +++ why?
  
  If containsGlobal Or linktable.count > 0 Then
  		
  		AlreadyLinked = New String[]
  		
  		While LinkTable.COUNT
         'Print "Inserting "; linktable[linktable.first]
         If Not AlreadyLinked.Exist(LinkTable.First) Then
            AlreadyLinked.Add(LinkTable.first)
  		      Program &= PreProcBuffer(linktable[linktable.first])
         Endif
         linktable.Remove(linktable.first)
      Wend
      
      ProgPart1 = "#!/usr/bin/gbs3\nExtern chdir(Dest As String) As Integer In \"libc:6\"\nUSE \"westwood.sharedmem\""
  		For Each sinsert In UseTable
        ProgPart1 &= "," & sinsert
      Next
  		ProgPart1 &= "\n"
  		
  		For Each sinsert As String In CompilerDirectiveTable
        ProgPart1 &= sInsert & "\n"
      Next
        
  		For Each sinsert In StructTable
        ProgPart1 &= sInsert & "\n"
      Next
      
  		For Each sinsert In ExternTable
        ProgPart1 &= sInsert & "\n"
      Next
     
      StructTable = New String[]
  		UseTable = New String[]
  		ExternTable = New String[]
  		CompilerDirectiveTable.Clear()
      
      Program = ProgPart1 & Program
      
  		If bSingleUse Then
         Program &= "Public Sub Main()\ntry chdir(env[\"PWD\"])\nSharedMem.Begin(" & BlockSize & ")\nwith Sharedmem\n"
      Else
  		   Program &= "Public Sub Main()\ntry chdir(env[\"PWD\"])\nSharedMem.BeginNamed(\"" & DefaultSharedMem & "\"," & BlockSize & ")\nwith Sharedmem\n"
      Endif
  		Program &= ExecBuffer 
  		Program &= "end with\nSharedMem.end()\nend\n"
  		'SharedMem["$execprog"] = ExecBuffer
  		If Not CompileOnly Then 
        Dim ScriptName As String = Temp("gsh_") & ".gsh"
        If DoTrace Then
          Error "(Trace "; Now; ") "; ("Execute External "); ": "; ScriptName
        Endif
        Try MyProg = Open ScriptName For Write Create
        If Not Error Then
            'Try rWrite(MyProg.handle, CPointer(program), Len(program))
            Try Write #MyProg, program, program.len
            If Not Error Then 
              Close MyProg
              If DoTrace Then 
                    For Each sdf As String In Split(program, "\n")
                        Error "(Trace "; Now; ") "; ("Execute External "); ": "; sdf
                    Next
              Endif
              'Chmod user.home & "/vars/ExecProg.gbs" To "rwxr-xr-x"
              SharedMem["$execprog"] = program
              eCmd = ["/usr/bin/gbs3", ScriptName]
              'If DoTrace Then ecmd.Add("-t", 1)
              eCmd.Insert(cmdLineParameters)
              If nowait Then
                'Try MyProcess = Exec ecmd With getenv() As "SysProc"
                Try MyProcess = Exec ecmd As "SysProc"
                If Error Then 
                    Error "Generated Script ="; ScriptName;; ":";; Error.text
                    ExecBuffer = ""
                    ReturnOutputTo = ""
                    LinkTable.clear()
                    ContainsGlobal = False
                    Return 
                Endif
                
                If MyProcess <> Null And If jobctl Then
                    ActiveProcesses.Add(MyProcess)
                    execline = Split(execbuffer, "\n", "", True)[0]
                    StartCopy = InStr(execline, "EXEC [", 0, gb.IgnoreCase)
                    If StartCopy > 0 Then Startcopy += 6 ' len of search string
                    EndCopy = InStr(execline, "] with", 0, gb.ignorecase)
                    If Endcopy > 0 Then
                        cmdjobsinfo = Mid(execline, StartCopy, endcopy - startcopy)
                    Else 
                        cmdjobsinfo = execline
                    Endif
                    sharedmem["pid.p" & MyProcess.id & Application.id] = Str(MyProcess.id) & "|" & Format(Now, "mm/dd/yyyy hh:nn:ss.uu") & "|" & cmdjobsinfo & "\n"
                   
                  '"sharedmem[\"pid.p\" & mProc" & BaseName & Str(i) & ".id]= str(mProc" & BaseName & Str(i) & ".id)&\"|\"& format(now,\"mm/dd/yyyy hh:nn:ss.uu\")& \"|\" & " & cmdjobsinfo & "\n"
                Endif
              Else
                Try MyProcess = Exec ecmd With getenv() As "SysProc"
                If Not Error Then 
                  RunningProcess = MyProcess
                  If jobctl Then RunningProcessStart = Now
                  MyProcess.Wait()
                  If jobctl Then
                    Error "Start="; Format(RunningProcessStart, "mm/dd/yyyy hh:nn:ss.uu"), "End="; Format(Now, "mm/dd/yyyy hh:nn:ss.uu"), "Duration="; (Now - RunningProcessStart) * 100000
                  Endif
                  RunningProcess = Null
                Endif
              Endif
            Else
              Close myprog
            Endif
  		  Endif
      Else
        compileScript = program
      Endif
  Else
  		'ProgramCommand = "gbs3 -e " & "'" & ExecBuffer & "'"
  		Dim cmd As String[] = ["/usr/bin/gbs3", "-e", ExecBuffer]
  		cmd.Insert(cmdLineParameters)
  		'Shell ProgramCommand Wait
  		If Not CompileOnly Then 
  		    If ReturnOutputTo <> "" Then
            'MyProcess = Exec cmd With SharedMem["$env"] For Read As "SystemRead" 
            MyProcess = Exec cmd With getenv() For Read As "SystemRead" 
          Else
            MyProcess = Exec cmd With getenv()
            'MyProcess = Exec cmd With SharedMem["$env"]
  		    Endif
  		
  		    If Not nowait Then 
              RunningProcess = MyProcess
              If jobctl Then RunningProcessStart = Now
              MyProcess.Wait()
     			    RunningProcess = Null
        	Endif
      Else
        compilescript = execbuffer
     	Endif
  Endif
  
  ExecBuffer = ""
  ReturnOutputTo = ""
  LinkTable.clear()
  ContainsGlobal = False
  
  Catch
     'Error Error.Text
     ExecBuffer = ""
     LinkTable.clear()
     ContainsGlobal = False
     Error.Propagate()
  
End

Public Sub SysProc_kill()

  If ActiveProcesses.count = 0 Then
    If jobctl Then Error "Complete pid="; RunningProcess.id; " State="; Process.LastState;; "Value="; Process.LastValue
    Return
  Endif
  
  For i As Integer = ActiveProcesses.Max To 0
    Select Case ActiveProcesses[i].state
      Case Process.Crashed
        sharedmem["pid.p" & ActiveProcesses[i].id & Application.id] &= "|" & Format(Now, "mm/dd/yyyy hh:nn:ss.uu") & "|" & ActiveProcesses[i].value & ("|[Crashed]\n")
        Error ("Job pid="); ActiveProcesses[i].id;; ("Crashed")
        ActiveProcesses.remove(i)

      Case Process.Running
        Continue
        
      Case Process.Signaled
        sharedmem["pid.p" & ActiveProcesses[i].id & Application.id] &= "|" & Format(Now, "mm/dd/yyyy hh:nn:ss.uu") & "|" & ActiveProcesses[i].value & ("|[Signaled]\n")
        Error ("Job pid="); ActiveProcesses[i].id;; ("Signaled")
        ActiveProcesses.remove(i)
        
      Case Process.stopped
        sharedmem["pid.p" & ActiveProcesses[i].id & Application.id] &= "|" & Format(Now, "mm/dd/yyyy hh:nn:ss.uu") & "|" & ActiveProcesses[i].value & ("|[Stopped]\n")
        Error ("Job pid="); ActiveProcesses[i].id;; ("Complete")
        ActiveProcesses.remove(i)

      Default
        Error "Job pid="; ActiveProcesses[i].id;; ("New State");; ActiveProcesses[i].state
    End Select
  Next
  
  Catch
    Error.Propagate()
  
End


Public Sub SystemRead_read()
  
  Dim sLine As String
  sLine = Read #Last, -256
  SharedMem[ReturnOutputTo] &= sLine
  
End

Public Sub SystemRead_kill()
  ' remove from job management comming soon!
End

Public Sub SystemRead_error(msg As String)
  
  Error ("System Read Error:");; msg
  
End


Public Sub PreProcBuffer(Proc As String) As String
Dim plist As String[]
Dim finalbuf As String = ""
''Debug "enter preprocbuffer"
plist = Split(proc, "\n")
For Each s As String In plist
   ' Debug "--> " & s
   If s <> "" Then finalbuf &= preprocesses(s) & "\n"
Next
Return finalbuf
Catch
  Error.Propagate()
End

Private ReadFromBuffer_buffer As New String[] 
Private ReadFromBuffer_readPtr As Integer = 0
Public Sub OpenBuffer(data As String)
  
  Source = "BUFFER"
  ReadFromBuffer_buffer = Split(data, "\n", "\"\"", True, True)
  ReadFromBuffer_readptr = 0
  
End

Public Sub ReadBuffer() As String
  If ReadFromBuffer_ReadPtr > ReadFromBuffer_buffer.max Then Return "QUIT"
  Inc ReadFromBuffer_ReadPtr
  Return ReadFromBuffer_buffer[ReadFromBuffer_ReadPtr - 1]
End

Public Sub ReadHistory() As String
   Dim ValLine As String = ""
   
   If history.Exist(Str(HCurrentRead)) Then
      ValLine = History[Str(HCurrentRead)]
      Inc hCurrentRead
   Endif

   Wait
   Return ValLine
   
   Catch 
     Error.Propagate()
End

Public Sub ReadFile() As String
  Dim thebuffer As String
  
   If Eof(AppSource) Then Return "QUIT"
   Try Line Input #AppSource, thebuffer
   If Error Then 
        Return "QUIT"
   Endif
   Wait
   Return theBuffer
   Catch 
     Error.Propagate()
End

Sub SetBlockIndent()
  With sharedmem
  If blocklevel = 0 Then
   blockindent = "\x00"
  Else
   blockindent = String(blocklevel, .["$blockindent"]) & "\x00"
  Endif
  End With
End

Public Sub readline() As String

  Dim pInput As Pointer
  Dim sInput As String
  Dim Prompt As String 
  
  If ReadLineVersion = -1 Then 
     ReadLineVersion = DetectReadlineVersion()
     SharedMem["readlineversion"] = readlineversion
   Endif
   
    If DoTrace Then Error ("Begin readline")
    
    If bDbaseServer Then
      If DoTrace Then Error ("Begin server mode reads")
      Dim rByte As Byte
      sInput = ""
      While True
        Read #file.in, rByte
        If rbyte = &H0A Then Break
        sInput &= Chr(rbyte)
      Wend
      sInput = Trim(sInput)
      If DoTrace Then Error "(Trace "; Now; ") ";; "Read line ="; sInput 
    Else
     Dim retryloop As Integer = 2
     retryprompt: 
     Wait
      If DoTrace Then Error ("Trying to read from terminal")
      If retryloop = 0 Then 
        Error ("Unable to evaluate any prompt type")
        prompt = "$"
      Else 
        Try prompt = Eval(SharedMem["$prompt"])
        If Error Then
          SharedMem["$prompt"] = DefaultPrompt
          Dec retryloop
          Goto retryprompt
        Endif
      Endif
      
      If DoTrace Then Error ("Reading From Readline Version");; readlineversion 
      SetBlockIndent()
      Select Case ReadLineVersion
        Case 9
              pinput = c9_readline(Prompt & BlockIndent)
        Case 8
              pinput = c8_readline(Prompt & BlockIndent)
        Case 7
              pinput = c7_readline(prompt & BlockIndent)
        Case 6
              pinput = c6_readline(prompt & BlockIndent)
        Case 5
              pinput = c5_readline(prompt & BlockIndent)
        Default 
              Error Prompt; "%"; BlockIndent;
              Line Input sInput
              sInput = Trim(sInput)
      End Select
    
      If ReadlineVersion > 4 Then
        
          If IsNull(pinput) Then Return "QUIT"
          
          If DoTrace Then Error "(Trace "; Now; ") ";; "Readline Input ="; String@(pinput)
          sInput = String(1, String@(pInput))
          rFree(pInput)
          sInput = Trim(sInput)
          If sInput <> "" Then add_history(sInput & "\x00")
      Endif
      If DoTrace Then Error ("Readline Complete")
    Endif
  
  Wait
  
  Return sInput
  
  Catch 
     Error.Propagate()
End


Public Sub IfReader(EndBlk As String[]) As Boolean
      Dim lastElement As String = ""
      Dim i As Integer
      Dim execbuff As String
      Dim HTypes As Integer[]
      Dim hStart As Integer = 0
      Dim filename As String
      If DoTrace Then Error "(Trace "; Now; ") ";; "Source input="; source
      If ReadQueue.IsEmpty Then
        Select Case source
       
         Case "BUFFER"
           Do
             inBuffer = Trim(ReadBuffer())
           Loop Until inBuffer <> ""
           
           If DoTrace Then Error "(Trace "; Now; ") ";; "Read Buffer '"; inbuffer; "'"
           
           If InBuffer = "QUIT" And inBuffer <> endblk.Join("") Then
                 Print File.err, ("Error reading File UNEXPECTED EOF , Wanted "); endblk.Join(" ")
                 execbuff = ""
                 Return False
           Endif
  
         Case "STDIN"
      			Do
      					inbuffer = readline()
      					If DoTrace Then Error "(Trace "; Now; ") ";; "Read Line '"; inbuffer; "'"
      			Loop Until InBuffer <> ""
      			
      	 Case "HISTORY"
              inBuffer = Trim(ReadHistory())
              add_history(inBuffer)
              If DoTrace Then Error "(Trace "; Now; ") ";; ("Read History '"); inbuffer; "'"
              
         Case "FILE"
              Do
                 inBuffer = Trim(ReadFile())
              Loop Until inBuffer <> ""
              'InBuffer = Trim(InBuffer)
              If InBuffer = "QUIT" And inBuffer <> endblk.Join("") Then
                 Print File.err, ("Error reading File UNEXPECTED EOF , Wanted "); endblk.Join(" ")
                 execbuff = ""
                 Return False
              Endif
              
         End Select
         
         If source = "STDIN" Then ' only record keystroke entries
            history = SharedMem["$history"]
            History.add(InBuffer, sharedMem["$historycurrent"])
            Inc SharedMem["$historycurrent"]
            If History.count > SharedMem["$maxhistory"] Then History.remove(History.first)
            SharedMem["$history"] = history
         Endif
         
      Else
         
         InBuffer = ReadQueue.Dequeue()
         
      Endif
       
      If InStr(InBuffer, "::") <> 0 Then
          Dim InList As String[] = Parser(InBuffer)
       
          If InList.count > 1 Then
              InBuffer = InList[0]
              For i As Integer = 1 To InList.Max
                  ReadQueue.Enq(InList[i])
              Next
          Endif
      Endif
       
      If DoTrace Then Error "(Trace "; Now; ") "; Endblk.Join(":"); ": "; InBuffer             ' allow to user to see each line as it is executed 
      
      InBuffer = CreateCmdProgram.AliasReplace(InBuffer)
      
      InBufParse = Highlight.Analyze(InBuffer)
      HTypes = Highlight.Types
      
      If HTypes[0] = Highlight.Comment Then Return True
      
      Dim newCmdLine As String = Preprocesses(InBuffer)
      
      If newCmdLine = "" Then Return True
      
      ExecBuffer &= newCmdLine & "\n"

      If InBufParse.max >= EndBlk.max Then
            Dim Truth As Integer = 0
            For i As Integer = 0 To EndBlk.max
              ''debug "Compare for endblock "; inbufparse[i]; " to "; Endblk[i]
              If Upper(InBufParse[i]) <> EndBlk[i] Then
                Break
              Else 
                  Inc Truth 
              Endif
            Next
            ''debug "Compare Truth "; truth, endblk.count
            If truth = EndBlk.count Then
              ''debug "IfRead found end"
              Return False
            Endif
      Endif
      'Print "type="; TypeToText[Highlight.Types[0]],HTypes[0]
      Dim parsepos As Integer = 0
      
      If InBufParse.count = 1 And If HTypes[0] = Highlight.symbol And If Not FunctionCommandOrexecVar(InBufParse[0]) Then
        Error.Raise(("UnKnown command or function , Can Not Be executed ") & InBufParse[0])
      Endif
      
StartAgain:
      Select Case HTypes[hstart]
            Case Highlight.Keyword
               Select Case Upper(InBufParse[parsepos])
                 Case "PUBLIC", "PRIVATE"
                  If HTypes.count > 3 And If hstart = 0 And If HTypes[hstart + 1] = Highlight.Symbol And If HTypes[hstart + 2] = Highlight.Keyword And If Upper(InBufParse[parsepos + 2]) = "AS" Then
                    ' If DoTrace Then Error "(Trace "; Now; ") "; ("\x1b[32mDefined Public to Extern table");; ExecBuffer;; "\x1b[0m"
                    ' Dim publicdef As String = getlastline(execbuffer)
                    ' execbuffer = removeLastLine(execbuffer)
                    ' ExternTable.Add(Publicdef)
                    ' 'execbuffer = ""
                    Return True
                    
                  Else
                    
                   Inc hstart
                   Inc ParsePos
                   Goto StartAgain
                   
                  Endif
                  
                 Case "STATIC"
                  Inc hstart
                  Inc ParsePos
                  Goto StartAgain
                  
                 Case "SUB", "FUNCTION", "PROCUDURE"
                   
                  If InLambda Then
                    lambdaSubFuncClass(["END"])
                    Return True
                  Endif
                   
                  If autocompile Then
                      Dim Saveexec As String = execbuffer
                      execbuffer = getlastline(execbuffer)
                      Saveexec = removeLastLine(Saveexec)
                  Endif
                  
                  If InBufParse.count < parsepos + 2 Then 
                     Error.Raise(InBufParse[parsepos] & (" requires a function name !"))
                     If AutoCompile Then execbuffer = ""
                     Return True
                  Else
                      If System.Keywords.Exist(inBufParse[parsepos + 1]) Then
                        Error.Raise(("Error: Reserved Word ") & inBufParse[parsepos + 1])
                        ExecBuffer = ""
                        Return True
                      Endif
                      If execbuffer[execbuffer.len - 1] = "\n" Then execbuffer = Left(execbuffer, execbuffer.len - 1)
                      If inbufparse.count < parsepos + 3 Then 
                            execbuffer &= "()"
                            'inbufparse[parsepos + 1] = inbufparse[parsepos + 1] & "()"
                      Else 
                            If inbufparse.count < parsepos + 4 Then
                              If inbufparse[parsepos + 2] <> "(" Then 
                                 Error.raise(("Error in sub definition ") & inBuffer)
                                execbuffer = ""
                                Return True
                             Endif
                            Endif
                      Endif
                      execbuffer &= "\n"
                          
                      If autocompile Then 
                        If Not sharedmem.exist("sub." & Lower(InBufParse[parsepos + 1])) Then
                      
                         LastElement = "sub." & Lower(InBufParse[parsepos + 1])
                          ' If inbufparse.count < parsepos + 3 Then 
                          '   execbuffer &= "()"
                          '   'inbufparse[parsepos + 1] = inbufparse[parsepos + 1] & "()"
                          ' Else 
                          '   If inbufparse.count < parsepos + 4 Then
                          '     If inbufparse[parsepos + 2] <> "(" Then 
                          '        Error.raise("Error in sub definition " & inBuffer)
                          '       execbuffer = ""
                          '       Return True
                          '    Endif
                          '   Endif
                          ' Endif
                          ' execbuffer &= "\n"
                          'SharedMem[lastelement] = "Sub " & Lower(InBufParse[parsepos + 1]) & "()\nEnd\n"
                        Else
                          If CommandMode Then
                            Error.Raise("Error :" & InBufParse[parsepos] & " " & InBufParse[parsepos + 1] & " Aready Defined")
                            NoPreProcess = True
                            DoBlock(["END"])
                            NoPreProcess = False
                          Else
                            Error.Raise(("Use Edit to change :") & InBufParse[parsepos] & " " & InBufParse[parsepos + 1] & (" ... Already Defined\n") & SharedMem["sub." & Lower(InBufParse[parsepos + 1])])
                          Endif
                          
                          ExecBuffer = ""
                          Return True
                        Endif
                      Endif
                   
                      NoPreProcess = True
                      DoBlock(["END"])
                      NoPreProcess = False
                      
                      If AutoCompile Then
                        SharedMem[Lower(LastElement)] = Trim(ExecBuffer)
                        ExecBuffer = ""
                      Endif
                      
                  Endif
                  
                  If AutoCompile Then
                      SharedMem.Sync(".", DefaultImageName)  ' write out image with new definition
                      If dotrace Then Error ("sub compile "); lastelement
                      compile(lastelement)
                  Endif
                  
                  If autocompile Then execbuffer = Saveexec
                  
                 Case "CLASS"
                  If InBufParse.count < 2 Then 
                     Error.Raise(InBufParse[0] & (" requires a class name !"))
                     execbuffer = ""
                  Else
                	     If Not SharedMem.exist("class." & Lower(InBufParse[1])) Then
                         LastElement = "class." & Lower(InBufParse[1])
                         SharedMem[LastElement] = "Class " & Lower(InBufParse[1]) 
                         ExecBuffer &= "\nExport\ninherits sharedclass\n"
                      Else
                         If CommandMode Then
                            Error.Raise("Error :" & InBufParse[0] & " " & InBufParse[1] & (" Aready Defined"))
                            NoPreProcess = True
                            DoBlock(["END", "CLASS"])
                            NoPreProcess = False
                            
                         Else
                            Error.Raise(("Use edit to change :") & InBufParse[0] & " " & InBufParse[1] & (" ... Already Defined\n") & SharedMem["class." & Lower(InBufParse[1])])
                         Endif
                         
                         ExecBuffer = ""
                         Return True
                      Endif
                   
                      NoPreProcess = True
                      AutoCompile = False
                      DoBlock(["END", "CLASS"])
                      NoPreProcess = False
                      AutoCompile = True
                      SharedMem[LastElement] = ExecBuffer
                      ExecBuffer = "" 
                  Endif
                  
                  SharedMem.Sync(".", DefaultImageName)
                  Debug "class compile "; lastelement
                  compile(lastelement)

                  
                 Case "STRUCT"
                   Dim data As String = getlastline(execbuffer) & "\n"
                   Dim StructName As String = InBufParse[parsepos + 1]
                   execbuffer = removeLastLine(execbuffer)
                   Dim OldExec As String = execbuffer
                   execbuffer = data
                   DoBlock(["END", "STRUCT"])
                   StructTable.Add("Public " & execbuffer)
                   sharedmem["struct." & Lower(StructName)] = "Public " & execbuffer
                   execbuffer = oldexec
                   
                 Case "REPEAT"
                   DoBlock("UNTIL")
                   
                 Case "FOR"
                   DoBlock(["NEXT"])
                   
                 Case "IF"
                   If Upper(inBufparse[InBufParse.max]) = "THEN"
                   		DoBlock(["ENDIF"])
                   Endif
                   
                 Case "DO"
                   DoBlock(["LOOP"])
                   
                 Case "WHILE"
                   DoBlock(["WEND"])
                   
                 Case "WITH"
                   DoBlock(["END", "WITH"])
                   
                 Case "SELECT"
                   DoBlock(["END", "SELECT"])
                   
               End Select
               ''debug "[ \n"; ExecBuffer; "\n]"
               Return True
               
            Case Highlight.Symbol
            
                Select Case Upper(inBufParse[0])
                  
                  Case "ALIAS"
                    If InBufParse.count = 1 Then
                      CreateCmdProgram.listAlias()
                    Else If Not InBufParse.Exist("=") Then
                      InBufParse.Remove(0)
                      CreateCmdProgram.listAlias(InBufParse.Join(""))
                    Else 
                      CreateCmdProgram.setalias(InBuffer)
                    Endif
                    execbuffer = ""
                    Return True
                    
                  Case "COMPILE"
                    CompileOnly = True
                    data = getlastline(execbuffer)
                    execbuffer = removeLastLine(execbuffer)
                    DoBlock(["END", "COMPILE"])
                    execbuffer = removeLastLine(execbuffer)
                    ProcessProg()
                    execbuffer = ""
                    CompileOnly = False
                    Try filename = Split(data, " ,\t")[1]
                    If Error Then 
                      filename = User.home &/ "bin" &/ "script.out"
                    Else
                      filename = UnQuote(filename)
                      If File.Dir(filename) = "" Then filename = User.home &/ "bin" &/ filename 
                    Endif 
                    
                    Try File.Save(filename, CompileScript)
                    If Error Then 
                        Error.raise(("Unable to create ") & filename)
                    Endif
                    Chmod filename To "rwxr-x--x"
                    Return True
                  
                  Case "LAMBDA", "BEGIN"
                    If Lambdalevel = 0 Then lambdabuffer = ""
                    Inc LambdaLevel
                    InLambda = True
                    lambdaExpression(["END"])
                    Dec LambdaLevel
                    If LambdaLevel = 0 Then InLambda = False
                    
                    
                 Case "RUN"
                    If inBufParse.count = 2 Then
                        execbuffer = ""
                        Dim scriptexit As Boolean
                        Try scriptexit = runscript(inBufParse[1])
                        If Error Then 
                          Error ("Error running script");; inBufParse[1];; Error.text
                        Endif
                        If scriptexit Then 
                           SharedMem["$result"] = "OK"
                        Else
                           SharedMem["$result"] = "ERROR"
                        Endif
                    Else
                        SharedMem["$result"] = ("Error : No Script named")
                        Error.Raise(("file not found.. Did you forget quotes"))
                    Endif
                    execbuffer = ""
                      
                 Case "HELP"
                    If InBufParse.count = 2 Then
                        PrintHelp(InBufParse[1])
                    Else
                        PrintHelp()
                    Endif
                    SharedMem.Free("$result")
                    SharedMem["$result"] = "OK"
                    execbuffer = ""
                    
                 Case "LIST"    ' list the last executed program or any program
                    If InBufParse.count = 2 Then
                        DoListing(InBufParse[1])
                    Else
                        DoListing("")
                    Endif
        
                   SharedMem.Free("$result")
                   SharedMem["$result"] = "OK"
                   execbuffer = ""
                    
                 Case "GET"     ' load a plugin into memory for use in the local command shell
                    LinkTable.Clear()
                    If inbufparse.count >= 2 Then 
                      execbuffer = ""
                      For inbc As Integer = 1 To inbufParse.Max
                          GetSub(InBufParse[inbc])
                      Next
                    Else
                      Error.Raise("Nothing to get")
                    Endif
                    SharedMem.Free("$result")
                    SharedMem["$result"] = "OK"
                    execbuffer = ""

                 Case "EDIT"    ' edit a class or Procedure
                     LinkTable.Clear()
                     SharedMem.Free("$result")
                     Dim funclass As String
                     If inbufParse.count >= 2 Then
                        If HTypes[1] = highlight.symbol Then
                       				funclass = "class." & inBufParse[1]
                       				If Not sharedmem.exist(funclass) Then
                       				   funclass = "sub." & inbufparse[1]
                       				   If Not Sharedmem.exist(funclass)
                                    funclass = inbufparse[1]
                                    If Not SharedMem.exist(funclass) Then funclass = ""
                       		  	   Endif
                             Endif
                             If funclass = "" Then
                           			    Dim iQuery As String = ""
                                   If System.Keywords.Exist(inBufParse[1]) Or If LocalKeyWords.Exist(inBufParse[1]) Then
                                     If Upper(inBufParse[1]) <> "LAMBDA" And If Upper(inBufParse[1]) <> "BEGIN" Then
                                        Error.Raise(("Error Keywords can not be redefined :") & inBufParse[1])
                                        SharedMem["$result"] = ("Error : Keywords can not be redefined :") & inBufParse[1]
                                        execbuffer = ""
                                        Return True
                                        
                                     Else
                                       If lambdabuffer = "" Then
                                         lambdabuffer = "sub.lambda(...)\n\nend\n"
                                       Endif
                                       lambdabuffer = editbuffer(lambdabuffer)
                                       Dim lambdaname As String = "lambda" & Str(linktable.count)
                                       LambdaBuffer = RegExp.Replace(LambdaBuffer, "^sub.*\\(", "sub " & lambdaname & "(")
                                       'If compilebuffer(lambdaname, lambdabuffer, True) Then ' it compiled ok
                                         linktable.Add(lambdabuffer, lambdaname)
                                         execbuffer = lambdaname & "()\n"
                                       'Else
                                         'Error.Raise("Bad Lambda expression")
                                         'execbuffer = ""
                                       'Endif
                                       Return True
                                     Endif
                                   Endif
                                   
                           			    Error Eval(SharedMem["$prompt"]) & inbufparse[1] & (" not found! Create {Class |Sub | Var | [No]} now ? ");
                                   Flush
    																Line Input iQuery
    																Select Case Upper(IQuery)
    																  Case "Class", "C"
                                        funclass = "class." & inBufParse[1]
                                        sharedMem[funclass] = "Class " & inbufParse[1] & "\nExport\nInherits SharedClass\nPublic Sub Dummy()\nprint \"Class here\"\nEnd\n"
                                        
                                     Case "SUB", "FUNCTION", "PROCEDURE", "S"
                                        funclass = "sub." & inBufParse[1]
                                        sharedmem[funclass] = "Sub " & inbufParse[1] & "()\nprint \"Sub here\"\nEnd\n"
                                        
                                     Case "VAR", "VARIABLE", "V"
                                        funclass = inBufParse[1]
                                        sharedmem[funclass] = ""
                                        
                                     Case "NO", "", "N"
                                      
                           			    End Select 
                           	Endif
                           		
                            If Not editanything(funclass) Then
                               execbuffer = ""
                               Return True
                            Else 
                               If funclass Like "class.*" Or funclass Like "sub.*" Then
                                   compile(funclass)
                               Endif
                            Endif
                           		
                        Endif
                     Endif
                     SharedMem["$result"] = "OK"
                     execbuffer = ""
                     SharedMem.Sync(".", DefaultImageName)
                     
                End Select

            Case Highlight.Function
            
            Case Highlight.Number
                If inBufParse.count = 2 Then 
                  If inBufParse[1] = "!" Then
                    Dec sharedMem["$historycurrent"]
                    History.remove(sharedMem["$historycurrent"])
                    sharedmem["$history"] = history
                    Return ExecFromHistory(CInteger(inBufParse[0]))
                  Endif
                Endif
                
            Case highlight.operator
                Select Case inBufParse[0]
                   Case "-"
                 				If inBufParse.count = 3 Then 
                 				 If HTypes[1] = highlight.number And inBufParse[2] = "!" Then
                 				   Dec sharedMem["$historycurrent"]
 													 History.remove(sharedMem["$historycurrent"])
 													 sharedmem["$history"] = history
                   				 Return ExecFromHistory(-CInteger(inBufParse[1]))
                         Endif
                 				Endif
                 				
                 	 Case "["    ' use this to recall a history and change its content
                          If inBufParse.count >= 3 Then
 												    If HTypes[1] = highlight.number And inBufParse[2] = "]" Then
     														Dec sharedMem["$historycurrent"]
                                  History.remove(sharedMem["$historycurrent"])
                                  sharedmem["$history"] = history
                                  editHistory(inBufParse[1])
                                  execbuffer = ""
                              Endif
                          Endif
                   '                                                
                End Select
                
             Case Highlight.Error
                Select Case InBufParse[0]
                 Case "{" ' begin compile block
                      
                    If Lambdalevel = 0 Then lambdabuffer = ""
                    Inc LambdaLevel
                    InLambda = True
                    lambdaExpression(["}"])
                    Dec LambdaLevel
                    If LambdaLevel = 0 Then InLambda = False
                          
                       
                 End Select      
      End Select
      
      Return True
      
      Catch
        NoPreProcess = False
        BlockLevel = 0
        ''debug "Exit DOBLK"
        Error.Propagate()
        'Error.Raise(Error.text)
End

Sub lambdaExpression(eblk As String[])

  Dim variables As String = GetLastLine(execbuffer)
  execbuffer = removeLastLine(execbuffer)
  Dim savebuf2 As String = execbuffer

  NoPreProcess = True
  DoBlock(eblk)
  NoPreProcess = False
  execbuffer = removeLastLine(execbuffer)
  Dim lambdaname As String = "lambda" & Str(linktable.count)
  lambdabuffer &= "sub " & lambdaname & "(...) as variant\n" & execbuffer & "\nend\n"
  If True Then
      linktable.Add(lambdabuffer, lambdaname)
      execbuffer = savebuf2 & lambdaname & "("
      Dim parms As String[] = Split(Variables, " \t,()", "\"\"", True, True)
      If parms.count > 1 Then
          For i As Integer = 1 To parms.max
            execbuffer &= parms[i]
            If i < parms.max Then execbuffer &= ","
          Next
      Endif
      Execbuffer &= ")\n"
  Else
      execbuffer = ""
      Error.Raise("Bad Lambda expression")
  Endif
  
  Catch
    NoPreProcess = False
    inLambda = False
    Error.Propagate()
End

Sub lambdaSubFuncClass(eblk As String[])
  Dim slambdabuffer As String = ""
  Dim sName As String = GetLastLine(execbuffer)
  execbuffer = removeLastLine(execbuffer)
  Dim savebuf2 As String = execbuffer
  NoPreProcess = True
  DoBlock(eblk)
  NoPreProcess = False
  execbuffer = removeLastLine(execbuffer)

  slambdabuffer = sName & "\n" & execbuffer & "\nend\n"
  
  LambdaBuffer = sLambdaBuffer & "\n" & lambdabuffer
  execbuffer = savebuf2
  
  Catch
    NoPreProcess = False
    Error.Propagate()
End


Sub editanything(funclass As String) As Boolean
  If funclass <> "" Then
      Dim cvString As Variant = sharedmem[funclass]
      If funclass Like "sub.*" Or If funclass Like "class.*" Then cvString = Trim(cvString)
      Select Case TypeOf(cvString)
          Case gb.String
              cvString = editbuffer(cvString)
              If funclass Like "sub.*" Or If funclass Like "class.*" Then cvString = Trim(cvString)
              sharedMem[funclass] = cvString
          Case gb.Object
              Dim cvBuffer As String[]
              Dim cvBufferString As String
              Dim cvVariantBuffer As Variant
              Dim cvLine As String
              Dim cvLineSet As String[]
              If Object.Class(cvString).Symbols.Exist("_edit") Then ' check if the object by some strange chance can edit itsself
                  SharedMem[funclass] = cvString._edit()
                  Return True
              Endif
              Select Case Object.Class(cvString).name 
                  Case "String[]"
                    cvBuffer = cvString
                    cvBufferString = cvBuffer.Join("\n", "\"\"")
                    cvBufferString = editbuffer(cvBufferString)
                    sharedMem[funclass] = Split(cvBufferString, "\n", "\"\"", True)
                    
                  Case "Byte[]"
                    SharedMem[funclass] = editHex(cvstring)
                    
                  Case "Collection"
                    cvBufferString = ""
                     For Each cvVariantBuffer In cvString
                       If TypeOf(cvVariantBuffer) = gb.string Then
                          cvBufferString &= "\"" & cvString.key & "\"=\"" & cvVariantBuffer & "\"\n"
                       Endif
                     Next
                     cvBufferString = editbuffer(cvBufferString)
                     cvBuffer = Split(cvBufferString, "\n", "\"\"", True, True)
                     For Each cvLine In cvBuffer
                       cvLineSet = Split(cvLine, "=", "\"\"", True, False)
                       If cvString.exist(cvLineSet[0]) Then
                          cvString[cvLineSet[0]] = cvLineSet[1]
                       Else
                          cvString.add(cvLineSet[1], cvLineSet[0])
                       Endif
                     Next
                     sharedMem[funclass] = cvString

                  Default
                    SharedMem["$result"] = ("Error : May not edit objects of type ") & Object.Class(cvString).name 
                    Return False
              End Select
          Default 
              SharedMem["$result"] = ("Error : May only edit strings and some objects")
              Return False
      End Select
  Endif
  Return True
   Catch 
     Error.Propagate()
End

Public Sub removeLastLine(sBuffer As String) As String
  
  Dim sLines As String[]
  Dim sBuff, sResult As String
  sResult = ""
  sLines = Split(sBuffer, "\n", "", True)
  sLines.Remove(sLines.Max)
  For Each sBuff In sLines
    sResult &= sBuff & "\n"
  Next
  Return sResult
Catch
  Error.Propagate()
End

Public Sub GetLastLine(sBuffer As String) As String
  
  Dim sLines As String[]
  sLines = Split(sBuffer, "\n", "", True)
  Return sLines.Last
Catch
  Error.Propagate()
End


Public Sub editbuffer(thebuffer As String) As String
''debug "edit "; thebuffer
Dim workfile As String = Temp() & ".gsh"
Dim Wfile As File
Dim resultfile As String
''debug "edit "; thebuffer
wfile = Open workfile For Write Create
Write #wfile, thebuffer, Len(thebuffer)
Close wfile

Shell "clear" Wait

'Dim cmd As String = sharedMem["$editor"] & " " & workfile
Dim mProc As Process
'mProc = Exec [SharedMem["$editor"], workfile] With SharedMem["$env"]
mProc = Exec [SharedMem["$editor"], "-l", workfile] With getenv()

 RunningProcess = mProc
 mProc.Wait()
 RunningProcess = Null

wfile = Open workfile For Read
Try resultfile = Read #wfile, Lof(wfile)
If Error Then resultfile = thebuffer
Close wfile

Return resultfile
 Catch 
     Error.Propagate()
End
Public Sub editHex(thebuffer As Byte[]) As Byte[]
''debug "edit "; thebuffer
Dim workfile As String = Temp()
Dim Wfile As File
Dim resultfile As Byte[]
''debug "edit "; thebuffer
wfile = Open workfile For Write Create
thebuffer.Write(wfile) 
Close wfile

Shell "clear" Wait

'Dim cmd As String = sharedMem["$editor"] & " " & workfile
Dim mProc As Process
'mProc = Exec [SharedMem["$hexeditor"], workfile] With SharedMem["$env"]
mProc = Exec [SharedMem["$hexeditor"], workfile] With getenv()

 RunningProcess = mProc
 mProc.Wait()
 RunningProcess = Null

wfile = Open workfile For Read
resultfile = New Byte[Lof(wfile)]
Try resultfile.Read(wfile)
If Error Then resultfile = thebuffer
Close wfile

Return resultfile
 Catch 
     Error.Propagate()
End

Public Sub editHistory(index As Integer) As Boolean

Dim MaxEdit As Integer = sharedMem["$historycurrent"] - 1
Dim EditNum As Integer = 0
Dim EditParts As String[]
Dim EditParms As String

EditParms = regexp.replace(InBuffer, "^.*]", "")
EditParts = Split(EditParms, "/", "''", True, False)             ' we should now have the correct edit info

If editparts.count <> 2 Then
    Error "Invalid replace parameters ", EditParms
    Return True
Endif

editnum = If(index < 0, Maxedit + index, index)
If editnum < 0 Or editnum > MaxEdit Then
    Error ("History index out of bounds ["); index; "]" 
    Return True
Endif
'Error "regexp.replace("; history[Str(editnum)]; "'"; EditParts[0]; ","; EditParts[1]; ")"
Dim resultbuf As String = regexp.replace(history[Str(editnum)], EditParts[0], EditParts[1])
Error Eval(sharedMem["$prompt"]); "["; editnum; "]";; resultBuf
history[Str(editnum)] = resultBuf
sharedmem["$history"] = history
 Catch 
     Error.Propagate()
End


Public Sub ExecFromHistory(Count As Integer) As Boolean
Dim bi As Boolean
  Dim readpos As Integer = If(count < 0, sharedMem["$historycurrent"] + count, count)
  If history.Exist(READPOS) Then
         	HCurrentRead = readpos
  Else
     			Error "No History at index  ="; readpos
     			execbuffer = ""
     			Return True
  Endif
  
  ''Debug "Access history number"; HCurrentRead
  
  execbuffer = ""
  Source = "HISTORY"
  bi = IfReader([""])
  SOURCE = "STDIN"
  Return bi
 Catch 
     Error.Propagate()
End

Public Sub DoBlock(EndBlk As String[])
With sharedmem
  Inc blockLevel
  ''debug "Enter DOBLK"
  While IfReader(endBlk)
    Wait
  Wend
  Dec BlockLevel
  ''debug "Exit DOBLK"

End With
 Catch
   Error.Propagate()
End

Private Sub FunctionCommandOrexecVar(symbol As String) As Boolean
  If isLocalFunc(symbol, False) Then Return True
  If System.Exist(symbol) Then Return True
  If LocalKeyWords.Exist(Lower(symbol)) Then Return True
  ' If SharedMem.exist(symbol) Then
  '   If SharedMem.SymbolTable[symbol].symtype = gb.string Then Return True
  ' Endif
  
  Return False
End

Private Sub isLocalFunc(msym As String, Optional docompile As Boolean = True) As Integer
  Dim sym As String = Lower(msym)
  
  If Not IsLetter(sym) Then Return False
  If Not SharedMem.exist("sub." & sym) Then
    If Exist(User.home &/ "vars/subs" &/ sym) Then
      Try SharedMem["sub." & sym] = File.Load(user.home &/ "vars/subs" &/ sym)
      If Error Then Error.Raise("IsLocalFunc:" & Error.text)
      If docompile Then
        If Not compile("sub." & sym) Then Return -1
      Endif
      Return True
    Else If Exist("/usr/share/gsh/subs" &/ sym) Then                ' check for a plugin
      Try SharedMem["sub." & sym] = File.Load("/usr/share/gsh/subs" &/ sym)
      If Error Then Error.Raise("IsLocalFunc:" & Error.text)
      If docompile Then
       If Not Compile("sub." & sym) Then Return -1
      Endif
      Return True
    Endif
  Else
    ' If DoCompile Then
    '   If Not Compile("sub." & sym) Then Return -1
    ' Endif
    Return True
  Endif
  
   Return False
  
  Catch
    Error.Propagate()
End

Private Sub isKeyword(sym As String) As Boolean
  If LocalKeyWords.Exist(Lower(sym)) Or If System.Keywords.Exist(sym) Then 
    Return True
  Endif
  
  Return False
   Catch 
     Error.Propagate()
End

Private Sub isLocalClass(msym As String, Optional docompile As Boolean = True, doclasscheck As Boolean = False) As Integer
  Dim c As Class
  Dim sym As String = Lower(msym)

  If Not IsLetter(sym) And If Not (sym Like "*_*") Then Return False
  If SharedMem.exist("class." & sym) Then Return True
  
  If Exist(User.home &/ "vars/class" &/ sym) Then
    Try SharedMem["class." & sym] = File.Load(user.home &/ "vars/class" &/ sym)
    If Error Then Error.Raise("IsLocalClass:" & Error.text)
    If docompile Then
      If Not compile("class." & sym) Then Return -1
    Endif
    Return True
    
  Else If Exist("/usr/share/gsh/class" &/ sym) Then                ' check for a plugin
    Try SharedMem["class." & sym] = File.Load("/usr/share/gsh/class" &/ sym)
    If Error Then Error.Raise("IsLocalClass:" & Error.text)
    If docompile Then
      If Not Compile("class." & sym) Then Return -1
    Endif
    Return True
  Endif
  
  If doclasscheck Then
    Try c = Classes[sym]
    If Not Error Then Return True
  Endif
  
  Return False
  
   Catch 
     Error.Propagate()
End

Private Sub isLocalstruct(msym As String, Optional docompile As Boolean = True) As Integer
  'Dim c As Class
  Dim sym As String = Lower(msym)
  
  If Not IsLetter(sym) And If Not (sym Like "*_*") Then Return False
  If SharedMem.exist("struct." & sym) Then Return True
  
  If Exist(User.home &/ "vars/struct" &/ sym) Then
    Try SharedMem["struct." & sym] = File.Load(user.home &/ "vars/struct" &/ sym)
    If Error Then Error.Raise("IsLocalStruct:" & Error.text)
    If docompile Then
      If Not compile("struct." & sym) Then Return -1
    Endif
      Return True
  Else If Exist("/usr/share/gsh/struct" &/ sym) Then                ' check for a plugin
    Try SharedMem["struct." & sym] = File.Load("/usr/share/gsh/struct" &/ sym)
    If Error Then Error.Raise("IsLocalStruct:" & Error.text)
    If docompile Then
      If Not Compile("struct." & sym) Then Return -1
    Endif
    Return True
  Endif
  
  'Try c = Classes[sym]
  'If Not Error Then Return True
  
  Return False
  
   Catch 
     Error.Propagate()
End

Private Sub MakeIntoCall(FuncName As String, CommandLine As String) As String

  Dim i, j As Integer
  Dim nowait As Boolean = False
  
  If Commandline[CommandLine.len - 1] = "&" Then 
      Commandline = Left(Commandline, CommandLine.len - 1)
      nowait = True
  Endif
  
  Dim Funcdef As String = getSubdef(Split(SharedMem["sub." & funcname], "\n", "\"\"", True))
  Dim interface As String[] = Split(FuncDef, "(,)", "\"\"", True, True)
  For i As Integer = 0 To interface.Max
    interface[i] = Trim(interface[i])
  Next
  Dim CmdLine As String[] = Split(CommandLine, " ", "[]\"\"", True, True)
  Dim sCodeLine As String = CmdLine[0] & "("
  Dim types As Integer[]
  Dim syms As String[]
  Dim DataTypePos As Integer = 0
  If Not interface.Exist("...")
    If CmdLine.max - 1 > interface.max - 1 Then
      SharedMem["$result"] = ("Error : Too many parameters :") & Split(SharedMem["sub." & funcname], "\n", "", True)[0]
      Return ""
    Endif
  Endif
  j = 1
  For i = 1 To CmdLine.max
   If i > 1 Then sCodeLine &= ","
   
    If interface[j] <> "..." And If Lower(interface[j]) <> "optional" Then
        syms = highlight.Analyze(interface[i])
        types = highlight.types
        DataTypePos = types.Find(Highlight.DataType)
        If DataTypePos > 0 Then
            If syms[DataTypePos] = "STRING" And CmdLine[i][0] <> "\"" Then
              sCodeLine &= "\"" & CmdLine[i] & "\""
            Else
              sCodeLine &= CmdLine[i]
            Endif
        Else
            sCodeLine &= CmdLine[i]
        Endif
        Inc j
    Else
       sCodeLine &= CmdLine[i]
    Endif
  Next
  
  sCodeLine &= ")"
  If nowait Then scodeline &= " &"
  
  Return sCodeLine
   Catch 
     Error.Propagate()
End


Public Sub PreProcesses(InVar As String) As String ' MaxGlobSize As 0 mean unlimited
  Dim OutBuf As String = ""
  Dim Syms As String[]
  Dim types As Integer[]
  Dim tCount As Integer
  Dim bLookup As Boolean = False
  
  If NoPreProcess Then 
     If DoTrace Then Error "(Trace "; Now; ") "; ("No Preprocess "); ": "; InVar   
      Return InVar
  Endif
  If DoTrace Then Error "(Trace "; Now; ") "; ("Before Preprocess "); ": "; InVar   
  If IsSpace(Invar) Then Return " "
  
  Syms = Highlight.Analyze(InVar)

  types = Highlight.types
  
  If syms.count = 0 Or If types[0] = Highlight.Comment Or If types[0] = Highlight.Help Then
    Return InVar
  Endif
  
  If syms[0] = "EXTERN" Then
        If Not ExternTable.Exist(InVar) Then
          ExternTable.Add(invar)
          syms[0] = "'" & syms[0]
        Endif
  Endif
  
  If syms.count >= 1 And syms.count <= 2 And syms[0] = "FAST" Then 
      If syms.count = 1 Or If syms[1] = "UNSAFE" Then        
         If Not CompilerDirectiveTable.exist(InVar) Then
            CompilerDirectiveTable.Add(InVar)
            Return "'" & InVar
         Endif
      Endif
  Endif
      
  If syms[0] = "USE" Then
        Dim uses As String[] = Split(invar, " ,", "\"\"", True, True)
        For dvi As Integer = 1 To uses.Max
          If Not UseTable.Exist(uses[dvi]) Then
            UseTable.Add(uses[dvi])
          Endif
        Next
        syms[0] = "' " & syms[0]
        Return Syms.Join(" ")
  Endif
  
  If (invar[0] = "." And invar[1] = "/") Or If (invar[0] = "~" And invar[1] = "/") Or If invar[0] = "/" Or If invar[0] = "*" Then 
     syms.Add("!", 0)
     types.Add(Highlight.operator, 0)
     
  Else If types[0] = Highlight.symbol Then                 ' check the type of symbol, look for function local override
     bLookup = System.Exist(syms[0])
    
    If bLookup And Not isLocalFunc(syms[0], True) And Not isKeyword(syms[0]) And Not isLocalClass(syms[0], True, True) And Not isLocalStruct(syms[0], False) Then
     syms.Add("!", 0)
     types.Add(Highlight.operator, 0)
    Else
      If SharedMem.exist("sub." & syms[0]) Then
        If syms.count = 1 Then
           syms.Add("(")
           syms.Add(")")
           types.Add(Highlight.Operator)
           types.Add(Highlight.operator)
        Else
            If syms[1] <> "(" Then
              Dim NewLineDef As String = MakeIntoCall(syms[0], InVar)
              Syms = Highlight.Analyze(NewLineDef)
              types = highlight.types
              
              If NewLineDef = "" Then
                  Error SharedMem["$result"]
                  Return ""
              Endif
            Endif
        Endif
      Endif
      bLookup = False
    Endif
  Endif
  
  'If types[0] = Highlight.operator And Syms[0] = "!" Then ' we treat this like an external command whole line
  If Syms[0] = "!" Then ' we treat this like an external command whole line
    outbuf = CreateCmdProgram.compile(InVar)
    If DoTrace Then Error "(Trace "; Now; ") "; ("PreProcess Cmd Compiled "); ": "; outbuf 
    ContainsGlobal = True
    
  Else
      tcount = 0
  		While tCount < Syms.count
        Select Case Types[tCount]
          
        Case Highlight.Error
          If syms[tCount][0] = "`" And If syms[tCount][syms[tCount].len - 1] = "`" Then
            syms[tCount] = Eval(Preprocesses(Mid(syms[tCount], 2, syms[tCount].len - 2)))
          Endif
          
        Case Highlight.string
          If Syms[tCount][1] = "#" And Syms[tCount].len >= 5 And syms[tcount][2] = "{" Then
            Dim sLtemp As String[] = Split(Mid(Syms[tcount], 2, Syms[tcount].len - 2), "#", "{}", True, False)
              sLtemp[0] = Replace(sLtemp[0], "'", "\"")
              Dim sx As String = PreProcesses(sLtemp[0])
              Dim PX As String 
              If DoTrace Then Error "(Trace "; Now; ") "; ("Preprocess Expand # "); ": "; sx  
              Try px = Str(Eval(sx))
              If Error Then
                Error "# Error in eval:"; Error.text
                Return ""
              Endif
              If DoTrace Then Error "(Trace "; Now; ") "; ("Preprocess After Expand #"); ": "; px 
              Try Syms[tCount] = PX
              If Error Then
                Error "# replace error :"; Error.text
                Error "#         error :"; sLtemp[0]
                Return ""
              Endif
          Endif

     		Case Highlight.symbol
         
          If Syms[Tcount] = "$" And If (tcount + 1) < types.count And If types[tcount + 1] = Highlight.String Then
            syms[tcount] = "enumerate"
            types[tcount] = Highlight.symbol
            syms.add(")", tcount + 2)
            types.Add(Highlight.operator, tcount + 2)
            syms.Add("(", tcount + 1)
            types.Add(Highlight.Operator, tcount + 1)
            
       		Else If Syms[tCount][0] = "$" Then
            Dim convit As Integer
            Try convit = CInteger(Mid(Syms[tCount], 2))
            If Not Error Then 
              If Compileonly Then
                 Syms[tCount] = "if(" & Str(convit) & "<args.count,Args[" & Str(convit) & "],\"\")"
              Else
                 If convit >= 0 And If convit <= cmdLineParameters.max Then
                   Syms[tCount] = If(IsNull(Val(cmdLineParameters[convit])) = True, Quote(cmdLineParameters[convit]), Val(cmdLineParameters[convit]))
                 Else
                    Syms[tcount] = ""
                 Endif
              Endif
            Else
              If Syms[tCount].len = 1 And If Syms[tCount + 1] = "#" Then
                If CompileOnly Then
                  Syms[tCount] = "Args.count"
                Else
                  Syms[tCount] = cmdLineParameters.count
                Endif
                Syms[tCount + 1] = ""
                Inc tCount
              Else
         		     ContainsGlobal = True
         		      If SharedMem.exist(Syms[tcount]) Then
                    If SharedMem.SymbolTable[Syms[tcount]].symtype = gb.object Then
                      Dim classname As String = SharedMem.SymbolTable[Syms[tcount]].ClassName
                      If SharedMem.exist("class." & classname) Then
                        LinkTable.Add(SharedMem["class." & classname], "class." & classname)
                      Endif
                    Endif
                  Endif
         		      Syms[tcount] = "SharedMem[\"" & Lower(Syms[tCount]) & "\"]"
              Endif
         	  Endif 
       		Endif
       		
       Case Highlight.Operator
         If syms.max >= tcount + 1 Then 
          If syms[tcount] = "@" And types[tcount + 1] = Highlight.symbol Then
            If SharedMem.exist(syms[tcount + 1]) Then
              Dim parm As New String[]
              Dim pCount As Integer = tcount + 2
              syms[tcount] = ""
              If syms.max > pCount Then
                If syms[pcount] = "(" Then
                  syms[pcount] = ""
                  Inc pcount
                  While Syms[pcount] <> ")" And pcount <= syms.Max
                    If syms[pcount] = "," Then 
                       syms[pcount] = ""
                    Else
                      parm.Add(syms[pcount])
                       syms[pcount] = ""
                    Endif
                    Inc pcount
                  Wend
                  
                  If Syms.max >= pcount Then
                    If Syms[pcount] = ")" Then
                      syms[pcount] = ""
                    Else
                      Error.Raise(("@ Improper parameter definition"))
                    Endif
                  Endif
                Endif
              Endif
              If DoTrace Then Error "(Trace "; Now; ") "; ("Preprocess before @"); ": "; syms[tcount + 1]
              Syms[tcount + 1] = execvar(syms[tcount + 1], parm)
              If DoTrace Then Error "(Trace "; Now; ") "; ("Preprocess After @"); ": "; syms[tcount + 1]
            Endif
          Endif
       	 Endif
     		End Select
  		Inc tcount
  		Wend
  		
  		' scan if we need to include a class, structure or function
  
  		For tcount = 0 To syms.max
  		       If types[tcount] = highlight.symbol Or If types[tcount] = Highlight.DataType Then
                  Dim FunClass As String
                  funclass = "class." & Lower(syms[tcount])
                  If Not isLocalClass(syms[tcount], False) Then
                       funclass = "sub." & Lower(syms[tcount])
                       If Not isLocalFunc(syms[tcount], False) Then
                         funclass = "struct." & Lower(syms[tcount])
                         If Not isLocalStruct(syms[tcount], False) Then
                          funclass = ""
                         Endif
                       Endif
                  Endif
                  If funclass <> "" Then
                     If funclass Like "struct.*" Then 
                        If Not StructTable.Exist(SharedMem[funclass]) Then
                          StructTable.Add(sharedmem[funclass])
                        Endif
                     Else If Not LinkTable.exist(funclass) Then
                         linktable.add(sharedmem[funclass], funclass)
                     Endif
                  Endif
             Endif
  		Next
  		
  		OutBuf = Syms[0]
  
  		For tcount = 1 To Syms.Max
        Dim sspacer As String = ""
         If tcount - 1 >= 0 Then
           
          If syms[tcount] = "." Then 
              If types[tcount - 1] = Highlight.symbol Or syms[tcount - 1] = "ERROR" Then
                  sspacer = ""
              Else
                  sspacer = " "
              Endif
          Else
              sspacer = " "
          Endif
        Endif
    		OutBuf &= sspacer & Syms[tcount]
  		Next
  		
      If DoTrace Then Error "(Trace "; Now; ") "; ("After Preprocess "); ": "; Outbuf 
       
      Highlight.Analyze(Outbuf, True)
  		OutBuf = Highlight.TextAfter
  		
  		Dim PublicCheck As Integer = IIf(syms[0] = "STATIC", 1, 0)
      If (syms[PublicCheck] = "PUBLIC" Or syms[PublicCheck] = "PRIVATE") And If syms.count > (3 + PublicCheck) And If types[1 + PublicCheck] = Highlight.symbol And If types[2 + PublicCheck] = Highlight.keyword And syms[2 + PublicCheck] = "AS" Then
        If Not ExternTable.Exist(OutBuf) Then
          ExternTable.Add(OutBuf)
          Outbuf = "'" & OutBuf
        Endif
      Endif
      
  Endif
  
 
  ''Debug OutBuf
  'Print OutBuf
  If DoTrace Then Error "(Trace "; Now; ") "; ("Preprocess outputs"); ": "; outbuf
  Return OutBuf
  
  Catch
    Error.Propagate()
  
End
'' resolve the file name to a single file if possible
'' glob it first and if its not found expand name and return it
Public Sub resolvefilename(filename As String) As String
  Dim results As String[] = CreateCmdProgram.DoGlob(filename)
  Dim newdir As String = results[0] 
  If results.count > 1 Then newdir = filename
   Dim name As String = File.Name(newdir)
   newdir = File.Dir(newdir)
   
   Dim sPath As String = Trim(newdir)
   
   Dim sPathSplit As String[] = Split(newdir, "/", "", True)
   
   Dim pwds As New String[]
   
   If file.isrelative(sPath) Then pwds.insert(Split(env["PWD"], "/", "", True))
   
   For Each Sdir As String In sPathSplit
     Select Case SDir
      Case "~"
        If pwds.count = 0 Then pwds.insert(Split(user.home, "/", "", True))
     
      Case "."
        If pwds.count = 0 Then pwds.insert(Split(env["PWD"], "/", "", True))
        
      Case ".."
        If pwds.count > 0 Then pwds.remove(pwds.max)
      
      Default 
         pwds.add(sdir)
                        
      End Select

      If Not Exist("/" & pwds.join("/")) Then 
        Error.raise(("Directory Not Found :[") & "/" & pwds.join("/") & "]")
      Endif
      
   Next
   Return "/" & PWDs.join("/") &/ name
End

Public ExecVarBuffer As String = ""
Public ExecProc As Process
Public Sub execvar_read()
  
   execvarbuffer &= Read #Last, -256
  
End

Public Sub execvar_error(procerr As String)
  
  Error procerr;
  
End

Public Sub execvar_kill()
  
  If DoTrace Then Error ("Execvar process ended")
  
End

Private Sub execvar(Varname As String, parm As String[]) As String
  
  If SharedMem.exist(VarName) Then
    parm.Add(varname, 0)
    parm.Add("-f", 0)
    If dotrace Then parm.Add("-t", 0)
    parm.Add("/usr/bin/gsh", 0)
    
    ExecVarBuffer = ""
    
    Try execproc = Exec parm For Read As "execvar"
    If Error Then Error Error.text
    execproc.Wait()
  Else 
    Error.Raise(("@ Unknown global variable\"") & varname & "\"")
  Endif
  
  If dotrace Then 
     Error ("Exec variable complete output: Start")
     Error ExecVarBuffer
     Error ("Exec variable complete output: End")
  Endif

  Return ExecVarBuffer

End

Public helptxt As String
Private Sub PrintLiveHelp(symbol As String[], Optional Summary As Boolean = False)
  With sharedmem
  Dim s As String
  
  For Each s In symbol
    If s Like "''*" Then
      HelpTxt &= Replace(s, "''", "") & "\n"
      If summary Then Break
    Endif
  Next
  End With
   Catch 
     Error.Propagate()
End

Public Sub GetHighlightTypeAsText(intype As Integer) As String
     If intype >= 0 And intype <= TypeToText.max Then
       Return TypeToText[intype]
     Endif
     Return ("UNKNOWN Highlight Type-") & Str(intype)
End
Public Sub GetDataTypeAsText(intype As Integer) As String
     If intype >= 0 And intype <= DataTypes.max Then
       Return DataTypes[intype]
     Endif
     Return ("UNKNOWN Data Type-") & Str(intype)
End

Public Sub GetAllThings() As Collection
  Dim AllCollection As Collection
  
  AllCollection = lany()
  Dim tClassStruct As Collection = lany("class", "class")
  For Each sv As String[] In tClassStruct
    AllCollection.Add(sv, tClassStruct.key)
  Next
  tClassStruct = lany("struct", "struct")
  For Each sv As String[] In tClassStruct
    AllCollection.Add(sv, tClassStruct.key)
  Next
  Return AllCollection
End


Public Sub printHelp(Optional command As String = "")
Dim mproc As Process

Dim helpCollection As Collection

With sharedmem
  Dim helplist As New String[]
  
  helpcollection = GetAllThings()
  
If command <> "" Then
  If helpCollection.exist(command) Then
    HelpTxt = ""
    PrintLiveHelp(helpgetfile(helpCollection[command][1]))
  Endif
Else
  HelpTxt = File.Load("/usr/share/gsh/doc/help.info")
  HelpTxt &= ("\nUseful included Functions and Classes these may be edited to your taste\nFunctions Can be found in /usr/share/gsh/subs for Default versions or in ~/vars/subs for personal versions")
  
  For Each sv As String[] In helpcollection
    helplist.Add(helpcollection.key)
  Next
  
  helplist.Sort()
  
  For Each ss As String In helplist
    printlivehelp(helpgetfile(helpCollection[ss][1]), False)
    helptxt &= "\n"
  Next
Endif

Dim helpretryCount As Integer = 0
helpRetry:
If helpRetryCount = 2 Then Error.Raise(("Help Display failed!"))
Try mproc = Exec .["$helpdisplay"] For Write
If Error Then 
    .["$helpdisplay"] = DefaultHelp
    Inc helpRetryCount
    Goto helpRetry
Endif

Wait
Write #mproc, Tr(Helptxt)
mproc.CloseInput()
mproc.Wait()

End With
 Catch 
     Error.Propagate()
End

Sub lany(Optional Stype As String = "sub", dirbase As String = "subs") As Collection
''lany(TypeOfFile,basDirectoryName,[filename] - prints a list of global functions, Subs, Procs,classes
''          prints the content of functuon if name is provided
''          function lsub/lclass(<subname>)
''          Command lsub/lcalss <subname>
''          returns true if found, false otherwise
''          $result contains the error text or "OK"
With sharedmem

    Dim tolist As New Collection
    Dim globdir As String[] = Dir("/usr/share/gsh" &/ dirbase, "*", gb.file)
    Dim locdir As String[] = Dir(user.home &/ "vars" &/ dirbase, "*", gb.file)
    Dim loadeddir As New String[]
    For Each sSyms As SharedMemSymbol In .SymbolTable
        If sSyms.symname Like sType & ".*" Then
            Try loadeddir.add(Split(sSyms.symname, ".")[1])
		If Error Then Error "lany " & error.text
        Endif
    Next
    For Each s As String In globdir
	If Not tolist.exist(s) Then tolist.add("", s)
        tolist[s] = [("Defaut"), "/usr/share/gsh/" &/ dirbase &/ s]
    Next

    For Each s In locdir
        tolist[s] = [("Personal"), user.home &/ "vars" &/ dirbase &/ s]
    Next

    For Each s In loadeddir
        tolist[s] = [("In Mem"), sType & "." & s]
    Next

End With

Return tolist

Catch
	Error.Propagate()
End


Sub helpgetfile(path As String) As String[]
Dim func As String
	If path[0] = "/" Then
		Try func = file.load(path)
		If Error Then
			 Error ("unable to read ") & path
			Return Null
		Endif
	Else
		func = sharedmem[path]
	Endif
	'func = ConsoleHighlight.ToConsole(func)
  Return Split(func, "\n", "\"\"", False, True)

End

Private Sub getSubdef(func As String[]) As String
For Each s As String In func
If s Like "*[Ss]ub *" Or If s Like "*[Ff]unction*" Or If s Like "*[Pp]rocedure*" Then Return s
Next
Return "*" & func[0]
End

Private Sub doListing(Command As String)
  
  Dim ListProg As String
  Dim AllList As Collection = GetAllThings()
  
  If Command <> "" Then
    If AllList.Exist(command) Then
        Dim listpath As String = AllList[command][1]
        If listpath[0] = "/" Then
          listprog = File.Load(listpath)
        Else
          listprog = SharedMem[listpath]
        Endif
    Else
        Try listprog = File.Load(CreateCmdProgram.MakeAbs(listpath))
        If Error Then Error.Raise(("List: Unable to find ") & InBufParse[1])
    Endif
  Else
    ListProg = LambdaBuffer & "\n"
    ListProg &= SharedMem["$execprog"]
  Endif
  
  Print ConsoleHighlight.ToConsole(ListProg)
  
End

