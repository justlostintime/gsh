' Gambas class file

' Gambas module file

Static Private syms As String[]
Static Private types As Integer[]
Static Private seperators As String[] = [" ", "\n"]
Static Private operators As String[] = ["::", "&&", "||", "(", ")"]
Static Private SpecialSymbols As String[] = ["{", "}"]
Static Private quotes As String[] = ["\"", "\""]
Static Private braces As String[] = ["{", "}"]


Static Private Sub SymsInsert(sym As String, type As Integer)
  sym = Trim(sym)
  If sym = "" Then
    Return
  Endif
  
  syms.Add(sym)
  types.Add(type)
  
End

'' process the input line and split it into seperate commands
Static Public Sub _call(InLine As String, Optional IncludeBreak As Boolean = False) As String[]

  Dim CurrentType As Integer = Highlight.Symbol
  Dim streamPos As Integer = 0
  Dim sym As String = ""
  Dim OutputList As New String[]

  InLine = Trim(InLine)
  
  syms = New String[]
  types = New Integer[]

  Do
    
    If seperators.Exist(InLine[streampos]) Then
      If sym.len > 0 Then
        SymsInsert(sym, CurrentType)
        sym = ""
        CurrentType = Highlight.Symbol
      Endif
      Inc streampos
      Continue
    Endif
    
    If SpecialSymbols.Exist(InLine[streampos]) Then
      If CurrentType <> Highlight.added And If sym.len > 0 Then
          SymsInsert(sym, CurrentType)
      Endif
      SymsInsert(InLine[streampos], Highlight.added)
      sym = ""
      CurrentType = Highlight.Symbol
      Inc StreamPos
      Continue
    Endif
    
    If operators.Exist(InLine[streampos]) Then
      If CurrentType <> Highlight.operator Then
        If sym.len > 0 Then
          SymsInsert(sym, CurrentType)
          sym = ""
          Currenttype = Highlight.operator
          sym &= InLine[streampos]
          Inc StreamPos
          Continue
        Else
          CurrentType = Highlight.Operator
        Endif
      Else
        If Not operators.Exist(sym & InLine[StreamPos]) Then
          SymsInsert(sym, CurrentType)
          sym = InLine[streampos]
          Inc streampos
          Continue
        Else
          sym &= InLine[StreamPos]
          Inc streampos
          Continue
        Endif
      Endif
    Else If streampos + 1 < InLine.len And If operators.Exist(InLine[StreamPos] & InLine[StreamPos + 1]) Then ' look ahead, limit 2
      If CurrentType <> Highlight.operator Then
        If sym.len > 0 Then
          SymsInsert(sym, CurrentType)
          sym = ""
        Endif
        CurrentType = Highlight.Operator
        sym &= InLine[StreamPos] & InLine[StreamPos + 1]
        StreamPos += 2
      Else
        If Not operators.Exist(sym & InLine[StreamPos] & InLine[StreamPos + 1]) Then
          SymsInsert(sym, CurrentType)
          sym = InLine[streampos] & InLine[streampos + 1]
          streampos += 2
          Continue
        Else
          sym &= InLine[StreamPos] & InLine[streampos + 1]
          streampos += 2
          Continue
        Endif
      Endif
    Endif
    
    If quotes.Exist(InLine[streampos]) Then  ' check for a quote character
      If sym.len > 0 Then
        SymsInsert(sym, CurrentType)
        sym = ""
      Endif
      
      CurrentType = Highlight.string
      
      Dim currentquote As String = InLine[StreamPos]
      Dim inquote As Integer = quotes.Find(currentquote)
      
      Inc inquote
      
      If inquote > quotes.max Or If inquote Mod 2 <> 1 Then
          Error.Raise("Invalid quote character \"" & currentquote & "\"\n" & Quote(inLine) & "\n")
      Endif
      
      currentquote = quotes[inquote]
      sym &= InLine[StreamPos] 
      Inc Streampos
      While StreamPos < InLine.len
        
        If InLine[StreamPos] = "\n" Then      ' end of line is as good as a close quote"
               Error.raise("Unmatched Quote  [" & currentquote & " ] in :" & Quote(inline))
        Endif
        
        sym &= InLine[StreamPos]
        
        If InLine[StreamPos] = currentquote Then
          Inc StreamPos
          Break
        Endif
        
        If InLine[StreamPos] = "\\" Then
          Inc StreamPos
          If streampos < inline.len Then 
             sym &= InLine[StreamPos]
          Else
             Error.raise("Unmatched Quote  [" & currentquote & "]  in :" & Quote(inline))
          Endif
        Endif
        
        Inc StreamPos
        
        If streampos = InLine.len Then 
               Error.raise("Unmatched Quote  [" & currentquote & "]  in :" & Quote(inline))
        Endif
        
      Wend
      
      SymsInsert(sym, CurrentType)
      sym = ""
      CurrentType = Highlight.symbol
      Continue
    Endif
    
    If InLine[StreamPos] = "\n" Or If InLine[StreamPos] = "'" Then Break
    
    If CurrentType = Highlight.Operator Then 
      If Not operators.Exist(sym & InLine[StreamPos]) Then
        SymsInsert(sym, CurrentType)
        sym = ""
        CurrentType = Highlight.symbol
      Endif 
    Endif
    
    sym &= InLine[StreamPos]
    Inc StreamPos
    
  Loop Until StreamPos >= InLine.Len 
  
   If sym.len > 0 Then
    SymsInsert(sym, CurrentType)
  Endif
  
  CheckBraces(syms)
  'find a way to make {} a special set
  
  'Divide the sets into single command lines
  Dim CurrentLine As Integer = 0
  Dim LastSegmentStart As Integer = 0
  Dim InSpecialSet As Integer = 0

  For i As Integer = 0 To syms.Max
    If types[i] = Highlight.added 
      If braces.Find(syms[i]) % 2 = 1 Then
         Inc InSpecialSet
      Else 
         Dec InSpecialSet
      Endif
    Endif
    If inSpecialSet = 0 Then 
      If types[i] = Highlight.operator Then
        If lastSegmentStart < i Then 
          OutputList.Add(syms.Copy(lastSegmentStart, i - lastSegmentStart).Join(" "))
        Endif
        LastSegmentStart = i + 1
       Inc CurrentLine
      Endif
    
      If IncludeBreak Then
        If types[i] = Highlight.operator Then
          OutputList.Add(syms[i])
        Endif
      Endif
    Endif
    
  Next
  
  If LastSegmentStart <= syms.max Then 
     OutputList.Add(syms.copy(lastSegmentStart, i - LastSegmentStart).Join(" "))
  Endif
  
  
  
  Return OutputList
  
  Catch
   Error.Propagate()
    
End 

Static Public Sub CheckBraces(symlist As String[], Optional start As Integer = 0, matching As String = "") As Integer
  Dim index As Integer = start
  Dim braceindex As Integer 
  
  If symlist.count = 0 Then Return 0
  
  While index < symlist.count
    If symlist[index].len > 1 Or If symlist[index] = "" Then 
       Inc index
       Continue
    Endif
    braceindex = braces.Find(symlist[index])
    If braceindex > -1 Then
               If braceindex % 2 = 0 Then ' have an opening brace
                   Inc index
                   index = CheckBraces(symlist, index, braces[braceindex + 1])
              Else If braceindex % 2 = 1 And If matching <> braces[braceindex] Then
                   Error.Raise("Missing/mismatched Bracket/brace [ " & Quote(IIf(matching <> "", matching, braces[braces.Find(symlist[index]) - 1])) & " ] in " & symlist.Join(" "))
              Else
                  Return index
              Endif
    Endif
    Inc index
  Wend
  If matching = "" Then
        Return 0
  Else
    Error.Raise("Missing closing Bracket/brace [ " & Quote(matching) & "  ] in " & symlist.Join(" "))
  Endif
End

' Gambas class file
