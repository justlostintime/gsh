' Gambas module file

Export

Public GLOB_ERR As Integer = Shl(1, 0)                     ' Return On Read errors. * /
Public GLOB_MARK As Integer = Shl(1, 1)                    ' Append a slash To Each name. * /
Public GLOB_NOSORT As Integer = Shl(1, 2)                  ' Don 't sort the names.  */
Public GLOB_DOOFFS As Integer = Shl(1, 3)                  ' Insert PGLOB - > gl_offs NULLs. * /
Public GLOB_NOCHECK As Integer = Shl(1, 4)                 ' If nothing matches, Return the pattern. * /
Public GLOB_APPEND As Integer = Shl(1, 5)                  ' Append To results Of a previous call. * /
Public GLOB_NOESCAPE As Integer = Shl(1, 6)                ' Backslashes don 't quote metacharacters.  */
Public GLOB_PERIOD As Integer = Shl(1, 7)                  ' Leading `.' can be matched by metachars.  */
Public GLOB_MAGCHAR As Integer = Shl(1, 8)                 ' Set In gl_flags If any metachars seen. * /
Public GLOB_ALTDIRFUNC As Integer = Shl(1, 9)              ' Use gl_opendir et al functions. * /
Public GLOB_BRACE As Integer = Shl(1, 10)                  ' Expand "{a,b}" To "a" "b". * /
Public GLOB_NOMAGIC As Integer = Shl(1, 11)                ' If no magic chars, Return the pattern. * /
Public GLOB_TILDE As Integer = Shl(1, 12)                  ' Expand ~user and ~ to home directories. */
Public GLOB_ONLYDIR As Integer = Shl(1, 13)                ' Match only directories. * /
Public GLOB_TILDE_CHECK As Integer = Shl(1, 14)            ' Like GLOB_TILDE but Return an Error
Public GLOB_FLAGS As Integer = (GLOB_ERR Or GLOB_MARK Or GLOB_NOSORT Or GLOB_DOOFFS Or GLOB_NOESCAPE Or GLOB_NOCHECK Or GLOB_APPEND Or GLOB_PERIOD Or GLOB_BRACE Or GLOB_NOMAGIC Or GLOB_TILDE Or GLOB_ONLYDIR Or GLOB_TILDE_CHECK)
Public Struct glob_t
   gl_pathc As Pointer                                     'Count Of paths matched by the pattern. * size_t we use pointer because it follows the correct length of size_t/
   gl_pathv As Pointer                                     'List Of matched pathnames.  char * * gl_pathv; * /
   gl_offs As Pointer                                      'Slots To reserve In `gl_pathv'.   __size_t gl_offs; */
   gl_flags As Integer                                     'Set To FLAGS, maybe | GLOB_MAGCHAR.  */
   gl_closedir As Pointer                                  'If the GLOB_ALTDIRFUNC flag Is Set, the following functions are used instead Of the normal file access functions.void( * gl_closedir)(void * )
   gl_readdir As Pointer                                   'Struct dirent * ( * gl_readdir)(void * );
   gl_opendir As Pointer                                   'void * ( * gl_opendir)(const char * );
   gl_lstat As Pointer                                     'Int( * gl_lstat)(const char * __restrict, struct stat * __restrict);
   gl_stat As Pointer                                      'Int( * gl_stat)(const char * __restrict, struct stat * __restrict);
End Struct

Extern glob(Pattern As String, flags As Integer, ErrorCallback As Pointer, glob_def As Glob_t) As Integer In "libc:6"
Extern globfree(glob_def As Glob_t) In "libc:6"

Public globerrors As String[] = ["No error", "Out Of Memory", "Read Error", "No Matches", "Not Implemented"]
Public AliasList As New Collection(gb.ignorecase)
Public MyReg As New Regexp
Public MyParams As New String[20]

Public Sub MakeAbs(newdir As String) As String
  
   'Dim sPath As String = Trim(newdir)
   Dim sPathSplit As String[] = Split(newdir, "/", "", True)
   Dim pwds As New String[]
   
  If sPathSplit.count = 0 Then 
     Return newdir
  Else If sPathSplit.count = 1 Then
     Return newdir
  Else
     For Each Sdir As String In sPathSplit
      Select Case SDir
       Case "~"
          If pwds.count = 0 Then pwds.insert(Split(user.home, "/", "", True))
     
       Case "."
          If pwds.count = 0 Then pwds.insert(Split(env["PWD"], "/", "", True))
        
       Case ".."
          If pwds.count > 0 Then pwds.remove(pwds.max)
      
       Default 
          pwds.add(sdir)
                        
      End Select
  
      Dim RealPath As String = "/" & pwds.join("/")
      Dim StatInfo As Integer = Stat(RealPath).mode
      If Not Exist(RealPath) Then 
        Error.Raise("Command Not Found :[" & RealPath & "]")
      Else If (StatInfo And &h49) = 0
        Error.Raise("Command file : [" & RealPath & "] Not executable")
      Endif
   
    Next
  Endif
   
   If pwds.count > 0 Then
   			 Return RealPath
   Else
       Return "/"
   Endif
End

Public Sub getfullpath(filename As String) As String
  
  Dim expandedList As String[]
  Dim pwds As New String[]
  
  Select Case filename[0]
    Case "/", "~", ".", ".."
      ' do nothing
      filename = filename
    Default
      filename = "." &/ filename
  End Select
   
  expandedList = DoGlob(filename)
  If expandedlist.count <> 1 Then
     Error.Raise("Too many files match [" & expandedlist.Join(" ; ") & "]")
  Endif
  If expandedlist[0] = filename Then
    If InStr(expandedlist[0], "*") Then
      Error.Raise("File not found [" & filename & "]")
    Endif
  Endif
  
  Dim sPathSplit As String[] = Split(expandedlist[0], "/", "", True)
  
  For Each Sdir As String In sPathSplit
      Select Case SDir
       Case "~"
          If pwds.count = 0 Then pwds.insert(Split(user.home, "/", "", True))
     
       Case "."
          If pwds.count = 0 Then pwds.insert(Split(env["PWD"], "/", "", True))
        
       Case ".."
          If pwds.count > 0 Then pwds.remove(pwds.max)
      
       Default 
          pwds.add(sdir)
                        
    End Select
   
   Next
   
   If pwds.count > 0 Then
   			 Return "/" &/ pwds.join("/")
   Else
         Return "/"
   Endif
  
End

'' This function will compile a Standard(SH) shell CLI line into gambas syntax

Public Sub Compile(Source As String) As String ' returns a correctly created program to run the command
   Dim lines As New String[]
   Dim FinalProgram As String = ""
   Dim BraceLevel As Integer = 0
   Dim AndOrLevel As Integer = 0
   Dim AndOrLevelStack As New Integer[]
   Dim i As Integer
   
   lines = Parser(Source, True)
   For i As Integer = 0 To lines.max
     If Lines[i] = "" Then Continue
     Select Case lines[i]
       Case "!"
         Continue
       Case "&&"
         If I = 0 Then Error.Raise("&& may not be at start of line")
         If I = lines.max Then Error.Raise("&& may not be at end of line")
         Inc AndOrLevel
         FinalProgram &= "If Process.LastValue = 0 then ' &&" & AndOrLevel & "\n"
       Case "||"
         If I = 0 Then Error.Raise("|| may not be at start of line")
         If I = lines.max Then Error.Raise("|| may not be at end of line")
         Inc AndOrLevel
         FinalProgram &= "If Process.LastValue <> 0 then ' ||" & AndOrLevel & "\n"
       Case "("
         AndOrLevelStack.Push(AndOrLevel)
         AndOrLevel = 0
         Inc BraceLevel
         FinalProgram &= "If True then\n"
       Case ")"
         FinalProgram &= "Endif\n"
         Dec BraceLevel
         AndOrLevel = AndOrLevelStack.Pop()       
          
       Default
         FinalProgram &= DoProcess(lines[i])
         If AndOrLevel Then 
           FinalProgram &= "EndIf\n"
           Dec AndOrLevel
         Endif
     End Select
   Next
   
   If BraceLevel > 0 Or BraceLevel < 0 Then Error.raise("Incorrect(unbalanced)  usage of '()' Braces in CLI")
   If AndOrLevel Then Finalprogram &= "Endif\n"
'   FinalProgram &= "Catch\nError \"gsh error:\" & error.text \n"
   Return FinalProgram
End

Private Sub IsGlob(Exp As String) As Boolean
  
  Select Case exp[0]
        Case "@", "/", "~"
          Return True
          
        Case "."
          If exp[1] = "/" Then Return True
          If exp.len = 1 Then Return True
          Return False
          
        Default
          If InStr(exp, "*") Then Return True
          
  End Select
  
  Return False
  
End



Private Sub DoProcess(source As String) As String ' returns the processed segment of the command line

  Dim CmdExec As New String[]       ' this will contain the exec line for each command
  Dim CmdIo As New String[]         ' this will contain the read functions for each command or rd wr if inside pipe stream
  Dim CmdErr As New String[]        ' Function if errors are captured
  Dim CmdWrite As New String[]      ' this will contain the write part for each command if outside of a pipe stream ie '< variable'
  Dim CmdKill As New String[]       ' This will have the close io functions when the task ends
  Dim CmdBeforeExec As New String[] ' list of things to do before starteing execs
  Dim CmdFinal As String = ""       ' This will contain the finished program segment and functions
  Dim CmdCount As Integer = 0       ' the number of the command we are processing
  Dim sym As String                 ' The currently processed symbol
  Dim CurrentCmd As Integer         ' Index of the command we are processing
  Dim CmdList As New String[][]     ' The first pass of command line collecting pipe connections
  Dim CmdTypes As New Integer[][]   ' the list of types for each value
  Dim CmdWriteTo As New Integer[]   ' This is the proc the command writes to
  Dim CmdReadFrom As New Integer[]  ' This is the proc the command reads from
  Dim CmdWriters As New Integer[][]    ' the list of writers to each command
  Dim WaitCompletion As Boolean = True ' wait for command to finish
  Dim InBlock As Boolean = False
  Dim BuildBlock As String             ' used to construct block a exec parameters
  Dim i As Integer
  Dim NoOutRedirect As Boolean = True
  Dim NeedsSTDIOWrite As Boolean = False
  Dim j As Integer
  Dim BaseName As String = "r" & Str(Rand(9999))

  'Dim NextedFinals As String[]        ' this is where the generated && and || will be statcked until added to final final
  
  parseline(Source)                   ' Parse the line and set the syms and types 
  
  Dim CurrentRead As Integer = 0      ' The proc to read from
  'Dim CurrentWrite As Integer = -2   ' On the first pass we dont know where to write to
  Dim x As New String[]
  Dim y As New Integer[]
  Dim z As New Integer[]
  
  CmdList.Add(x)    ' Setup entries for first command
  CmdTypes.Add(y)
  CmdExec.Add("")
  CmdIo.Add("")
  CmdWrite.Add("")
  CmdErr.Add("")
  CmdKill.Add("")
  CmdReadFrom.Add(-1)
  CmdWriteTo.Add(-2)
  CmdWriters.add(z)
  
  i = 0                     ' bypass the first ! command notation
  Do                        ' Break the command down into pipes
    sym = syms[i]
    Select Case sym 
    Case "!", "|"
       x = New String[]
       y = New Integer[]
       z = New Integer[]
       CmdList.Add(x)     ' setup entries for the next command
       CmdTypes.Add(y)
       CmdExec.Add("")
       CmdIo.Add("")
       CmdWrite.Add("")
       CmdErr.Add("")
       CmdKill.Add("")
       cmdReadFrom.Add(CurrentRead)
       CmdWriteTo.Add(-2)
       CmdWriters.add(z)
       Inc CmdCount
       CurrentRead = CmdCount
       Inc i
       Continue

    Case "|>"
       x = New String[]
       y = New Integer[]
       z = New Integer[]
       CmdList.Add(x)     ' setup entries for the next command
       CmdTypes.Add(y)
       CmdExec.Add("")
       CmdIo.Add("")
       CmdWrite.Add("")
       CmdErr.Add("")
       CmdKill.Add("")
       cmdReadFrom.Add(CurrentRead)
       CmdWriteTo.Add(-3)      ' -3 tells us this is a tee for the pipe fitting
       CmdWriters.add(z)
       Inc CmdCount
       Inc i
       Continue
       
     Case "|<"
       x = New String[]
       y = New Integer[]
       z = New Integer[]
       CmdList.Add(x)     ' setup entries for the next command
       CmdTypes.Add(y)
       CmdExec.Add("")
       CmdIo.Add("")
       CmdWrite.Add("")
       CmdErr.Add("")
       CmdKill.Add("")
       cmdReadFrom.Add(-3) ' -3 tells us this is a tee for the pipe fitting
       CmdWriteTo.Add(CurrentRead)
       CmdWriters.add(z)
       Inc CmdCount
       Inc i
       Continue
      
    Default
      CmdList[CmdCount].Add(sym)
      CmdTypes[CmdCount].Add(types[i])
      
    End Select
    Inc i
    gsh.LinkTable.Add("Private cmdBuild as new string[]\n", "cmdBuild")
  Loop Until i > syms.max
  
  For CurrentCmd = 0 To CmdList.Max
    Dim bFirst As Boolean = True
    gsh.LinkTable.Add("Public mProc" & BaseName & Str(CurrentCmd) & " As process\n", "mProc" & BaseName & Str(CurrentCmd))
    
    If CmdKill[CurrentCmd] = "" Then CmdKill[CurrentCmd] = SetKillSub(CurrentCmd, basename)
    
    CmdExec[CurrentCmd] = "cmdBuild.clear()\n" 
    
    BuildBlock = ""
    For i = 0 To CmdList[CurrentCmd].max
      Sym = CmdList[CurrentCmd][i]
      If i = 0 And CurrentCmd > 0 Then ' verify that this is a valid command
         If Cmdtypes[CurrentCmd][i] <> Highlight.function And If Cmdtypes[currentCmd][i] <> Highlight.label Then
           Try sym = System.find(sym)
           If Error Or If sym = "" Then Error.Raise("Pipe Fitting error: Command/Function [" & CmdList[CurrentCmd][i] & "] Unknown")
         Endif
      Endif
      
      Select Case sym
        
      Case "&" ' error redirection we hope or send to bg
        If CurrentCmd = CmdList.max And i = CmdList[CurrentCmd].max Then 'we have a background request
            WaitCompletion = False
            Continue
        Else
            ' ignore the & if not in last position
            Error.Raise(" & not last symbol in command for background request")
        Endif
         
      Case "&>", "&>>"
        Inc i
        If i > CmdList[CurrentCmd].max Then Error.Raise("Missing Error redirection destination")
         If i + 1 <= CmdList[CurrentCmd].max And If CmdList[CurrentCmd][i + 1][0] = "(" Then
          Inc i
          CmdList[CurrentCmd][i] = CmdList[CurrentCmd][i - 1] & CmdList[CurrentCmd][i]
        Endif
        If CmdErr[CurrentCmd] = "" Then CmdErr[CurrentCmd] = SetErrSub(CurrentCmd, basename)
        If CmdIo[CurrentCmd] = "" Then CmdIo[CurrentCmd] = SetIoSub(CurrentCmd, basename)
        
        If IsGlob(CmdList[CurrentCmd][i]) Then
          Dim notfile As Boolean = False
          Dim fullname As String 
          If CmdList[CurrentCmd][i][1] = "(" Then
              Dim sline As String[] = Split(CmdList[CurrentCmd][i], "()", "\"\"", True, True)
              If sline.count >= 2 Then fullname = gsh.preprocesses(sline[1])
              notfile = True
          Else
              Dim outname As String = File.Name(If(CmdList[CurrentCmd][i][0] = "@", Mid(CmdList[CurrentCmd][i], 2), CmdList[CurrentCmd][i]))
              Dim fileext As String = Rand(333, 670990909)
              Dim outfiledir As String = getfullpath(File.Dir(If(CmdList[CurrentCmd][i][0] = "@", Mid(CmdList[CurrentCmd][i], 2), CmdList[CurrentCmd][i])))
              fullname = outfiledir &/ outname
          Endif
          gsh.LinkTable.Add("Public OutFile" & BaseName & fileext & " as File\n", "OutFile" & BaseName & fileext)
          If sym = "&>" Then 
            CmdBeforeExec.Add("OutFile" & BaseName & fileext & " = open " & If(notfile = True, fullname, Quote(fullname)) & " for write create\n")
          Else
            CmdBeforeExec.Add("OutFile" & BaseName & fileext & " = open " & If(notfile = True, fullname, Quote(fullname)) & " for write append\n")
          Endif
          
          Cmderr[Currentcmd] &= "write #OutFile" & BaseName & fileext & ", msg,msg.len\n"
          If CmdKill[CurrentCmd] = "" Then CmdKill[CurrentCmd] = SetKillSub(CurrentCmd, basename)
          CmdKill[Currentcmd] &= "Close Outfile" & BaseName & fileext & "\n"
          
        Else
          If sym = "&>" Then CmdBeforeExec.Add(gsh.preProcesses(CmdList[CurrentCmd][i]) & " = \"\"\n")     ' Define a line to set it to zero only if not append
          CmdErr[CurrentCmd] &= gsh.preprocesses(CmdList[CurrentCmd][i]) & " &= msg\n"
          
        Endif
        
        NeedsSTDIOWrite = True
          
    
      Case ">", ">>" ' Output features
        Inc i
         If i > CmdList[CurrentCmd].max Then Error.Raise("Missing output redirection destination")
         
         If i + 1 <= CmdList[CurrentCmd].max And If CmdList[CurrentCmd][i + 1][0] = "(" Then
          Inc i
          CmdList[CurrentCmd][i] = CmdList[CurrentCmd][i - 1] & CmdList[CurrentCmd][i]
        Endif
        
        If CmdIo[CurrentCmd] = "" Then CmdIo[CurrentCmd] = SetIoSub(CurrentCmd, basename)
        
        If IsGlob(CmdList[CurrentCmd][i]) Then 
          notfile = False
          If CmdList[CurrentCmd][i][1] = "(" Then
              sline = Split(CmdList[CurrentCmd][i], "()", "\"\"", True, True)
              If sline.count >= 2 Then fullname = gsh.preprocesses(sline[1])
              notfile = True
          Else
              outname = File.Name(If(CmdList[CurrentCmd][i][0] = "@", Mid(CmdList[CurrentCmd][i], 2), CmdList[CurrentCmd][i]))
              fileext = Rand(333, 670990909)
              outfiledir = getfullpath(File.Dir(If(CmdList[CurrentCmd][i][0] = "@", Mid(CmdList[CurrentCmd][i], 2), CmdList[CurrentCmd][i])))
              fullname = outfiledir &/ outname
          Endif
          gsh.LinkTable.Add("Public OutFile" & BaseName & fileext & " as File\n", "OutFile" & BaseName & fileext)
          If sym = ">" Then 
            CmdBeforeExec.Add("OutFile" & BaseName & fileext & " = open " & If(notfile = True, fullname, Quote(fullname)) & " for write create\n")
          Else
            CmdBeforeExec.Add("OutFile" & BaseName & fileext & " = open " & If(notfile = True, fullname, Quote(fullname)) & " for write append\n")
          Endif
          
          CmdIo[Currentcmd] &= "write #OutFile" & BaseName & fileext & ", sInput,sInput.len\n"
          If CmdKill[CurrentCmd] = "" Then CmdKill[CurrentCmd] = SetKillSub(CurrentCmd, basename)
          CmdKill[Currentcmd] &= "Close Outfile" & BaseName & fileext & "\n"
          
        Else
          If sym = ">" Then 
            If CmdTypes[CurrentCmd][i] <> Highlight.function Then 
               CmdBeforeExec.Add(gsh.preProcesses(CmdList[CurrentCmd][i]) & " = \"\"\n")     ' Define a line to set it to zero only if not append
            Endif
          Endif 
        
          If CmdTypes[CurrentCmd][i] = Highlight.function Then
            Dim tempcmd As String = gsh.preProcesses(CmdList[CurrentCmd][i])
            tempcmd = Replace(tempcmd, "()", "(" & "sInput" & ")")
            CmdIo[CurrentCmd] &= tempcmd & "\n"  ' send data to the global variable
          Else
            If cmdlist[CurrentCmd][i][0] = "$" Then ' if it is not there just make it
              If Not SharedMem.exist(cmdlist[CurrentCmd][i]) Then SharedMem[cmdlist[CurrentCmd][i]] = ""
            Endif
            CmdIo[CurrentCmd] &= gsh.preProcesses(CmdList[CurrentCmd][i]) & " &= sInput\n"  ' send data to the global variable
          Endif
        Endif
       
        NoOutRedirect = False
     
      Case "<" 'input features
        Inc i
        If i > CmdList[CurrentCmd].max Then Error.Raise("Missing input redirection destination")
        If i + 1 <= CmdList[CurrentCmd].max And If CmdList[CurrentCmd][i + 1][0] = "(" Then
          Inc i
          CmdList[CurrentCmd][i] = CmdList[CurrentCmd][i - 1] & CmdList[CurrentCmd][i]
        Endif
        'CmdWrite[CurrentCmd] &= "Write #mProc" & Str(CurrentCmd) & " , " & gsh.PreProcesses(CmdList[CurrentCmd][i]) & "\n"
        If Not gsh.LinkTable.Exist("sub.fprint") Then gsh.LinkTable.add(SharedMem["sub.fprint"], "sub.fprint")
        
        If IsGlob(CmdList[CurrentCmd][i]) Then
          Dim filename As String = getfullpath(If(CmdList[CurrentCmd][i][0] = "@", Mid(CmdList[CurrentCmd][i], 2), CmdList[CurrentCmd][i]))
          If Exist(filename) And If Stat(filename).Type = gb.file Then
             CmdWrite[CurrentCmd] &= "fprint(mProc" & BaseName & Str(CurrentCmd) & " , file.load(" & Quote(filename) & "))\n"
          Else
             CmdWrite[CurrentCmd] &= "fprint(mProc" & BaseName & Str(CurrentCmd) & " , file.load(" & Quote(filename) & "))\n"
          Endif
        Else
          CmdWrite[CurrentCmd] &= "fprint(mProc" & BaseName & Str(CurrentCmd) & " , " & gsh.PreProcesses(CmdList[CurrentCmd][i]) & ")\n"
        Endif
        
      Case "!>" ' Write the return value from the exec to this variable
        Inc i
         If i > CmdList[CurrentCmd].max Then Error.Raise("Missing CLI return code destination")
        CmdKill[CurrentCmd] &= gsh.PreProcesses(CmdList[CurrentCmd][i]) & " = mProc" & BaseName & Str(CurrentCmd) & ".value\n"
        
      Default
        Dim sTemp As String = ""
        If bFirst Then
            Select Case CmdTypes[CurrentCmd][i]
              Case Highlight.function    ' remember we used this to mean local function
                CmdExec[CurrentCmd] &= "CmdBuild.add(\"/usr/bin/gsh\")\nCmdBuild.add(\"-r\")\nCmdBuild.add(" & Quote(sym) & ")\n"
                
              Case Highlight.label
                CmdExec[CurrentCmd] &= "CmdBuild.add(\"/usr/bin/gsh\")\nCmdBuild.add(\"-f\")\nCmdBuild.add(" & Quote(sym) & ")\n"
                
              Default
                Dim rTemp, rrTemp As String 
                gsh.PreProcesses("tostringarray()")
                sym = MakeAbs(sym)
                If Not IsNull(sym) Then 
                   Dim currentcmdname As String = "Cmd" & BaseName 
                   gsh.LinkTable.add("Const " & currentcmdname & " As String = " & Quote(System.Find(sym)), currentcmdname)
                   CmdExec[CurrentCmd] &= "tostringarray(CmdBuild," & currentcmdname
                Endif
                
            End Select
            bFirst = False
        Else
           'If Not InBlock Then CmdExec[CurrentCmd] &= "\n"
           If Left(sym, 2) = "--" Then                          ' take care of options
             rtemp = UnQuote(preprocess(Right(sym, -2)))
             rrtemp = "--"
             rtemp = rrtemp & Rtemp
             CmdExec[CurrentCmd] &= "," & Quote(rTemp)
            
           Else If sym[0] = "-" Then
             rtemp = "-" & UnQuote(preprocess(Mid(sym, 2)))
            CmdExec[CurrentCmd] &= "," & Quote(rTemp)
            
          Else                                                      ' not an option
            Dim Preprocstuff As String
            If sym = "$" And If CmdTypes[CurrentCmd][i + 1] = Highlight.string Then                           ' handle all special shell functions
              CmdExec[CurrentCmd] &= "," & gsh.PreProcesses("$" & cmdlist[CurrentCmd][i + 1])
              Inc i
            Else
                PreProcStuff = If(CmdTypes[CurrentCmd][i] = Highlight.added, Quote(sym), preprocess(sym, InBlock))
            Endif 
            If Preprocstuff = "(" Then 
               'Dim addcomma As Boolean = False
               'CmdExec[CurrentCmd] &= "tostringarray(CmdBuild," 
               InBlock = True
            Else If PreprocStuff = ")" Then 
               'CmdExec[CurrentCmd] &= ")\n"
               InBlock = False
            Else
               If InBlock Then 
                  'If addcomma Then CmdExec[CurrentCmd] &= ","
                  If preProcStuff <> "" Then CmdExec[CurrentCmd] &= "," & PreProcStuff
                  'addcomma = True
               Else
                    If Not IsNull(PreprocStuff) Then CmdExec[CurrentCmd] &= "," & PreProcStuff 
               Endif
            Endif
            
          Endif
           
        Endif
        
      End Select
      
    Next
    
    'CmdExec[CurrentCmd] &= "]" ' with sharedmem[\"$env\"] "
    CmdExec[CurrentCmd] &= ")\n"
    CmdExec[CurrentCmd] &= "\n''#" & CmdList[currentcmd].Join(" ") & "#''\n"
    CmdExec[CurrentCmd] &= "\nmProc" & BaseName & Str(CurrentCmd) & " = Exec cmdBuild "
    
     If CmdWriteTo[CurrentCmd] >= 0 Then   ' we need to do the write to the next command in pipe
       If CmdIo[CurrentCmd] = "" Then CmdIo[CurrentCmd] = SetIoSub(CurrentCmd, basename)
       CmdIo[CurrentCmd] &= "write #mProc" & BaseName & Str(CmdWriteTo[CurrentCmd]) & ", sInput\n"
       If CmdKill[CurrentCmd] = "" Then CmdKill[CurrentCmd] = SetKillSub(CurrentCmd, basename)
       CmdKill[CurrentCmd] &= "if mClose" & BaseName & Str(CmdWriteTo[CurrentCmd]) & "() then mProc" & BaseName & Str(CmdWriteTo[CurrentCmd]) & ".closeinput()\n"
       If CmdWrite[CmdWriteTo[CurrentCmd]] = "" Then
         CmdWrite[CmdWriteTo[CurrentCmd]] = " "
       Endif
       CmdWriters[CmdWriteTo[CurrentCmd]].add(CurrentCmd)
       NoOutRedirect = False
    Else If CmdReadFrom[CurrentCmd] >= 0 Then ' we are a read from we have to add this
       If CmdIo[CmdReadFrom[CurrentCmd]] = "" Then CmdIo[CmdReadFrom[CurrentCmd]] = SetIoSub(CmdReadFrom[CurrentCmd], basename)
       If CmdKill[CmdReadFrom[CurrentCmd]] = "" Then CmdKill[CmdReadFrom[CurrentCmd]] = SetKillSub(CmdReadFrom[CurrentCmd], basename)
       CmdIo[CmdReadFrom[CurrentCmd]] &= "write #mProc" & BaseName & Str(CurrentCmd) & ", sInput\n"
       CmdKill[CmdReadFrom[CurrentCmd]] &= "if mClose" & BaseName & Str(CurrentCmd) & "() then mProc" & BaseName & Str(CurrentCmd) & ".closeinput()\n"
       CmdWriters[CurrentCmd].add(CmdReadFrom[CurrentCmd])
    Endif
    
    If NoOutRedirect And NeedsSTDIOWrite Then CmdIo[CurrentCmd] &= "write #File.out, sInput\n"
    If CmdWrite[CurrentCmd] <> "" And CurrentCmd = 0 Then CmdWrite[CurrentCmd] &= "mProc" & BaseName & Str(CurrentCmd) & ".closeinput()\n"   ' do this only on first, allows to inject data to stream
  Next
  
  CmdFinal = ""
  
  For Each sym In CmdIo   ' setup all the read functions
    Dim Vset As String[] = Split(sym, "|", "\"\"", True, True)
    If sym <> "" Then 
      Vset[1] &= "end with\nend\n"
      gsh.LinkTable.Add(Vset[1], Vset[0])               'CmdFinal &= sym
    Endif
  Next
  
  For Each sym In CmdErr
    Vset = Split(sym, "|", "\"\"", True, True)
    If sym <> "" Then 
       Vset[1] &= "end with\nend\n"
       gsh.LinkTable.Add(Vset[1], Vset[0])               'CmdFinal &= sym
    Endif
  Next
  
  For Each sym In CmdKill
    Vset = Split(sym, "|", "\"\"", True, True)
    If sym <> "" Then 
        Vset[1] &= "end with\nend\n"
        gsh.LinkTable.Add(Vset[1], Vset[0])               'CmdFinal &= sym
    Endif
  Next
  
  For j = 0 To CmdWriters.Max
    If CmdWriters[j].count = 0 Then Continue
    gsh.LinkTable.add(BuildClose(j, CmdWriters[j], basename), "mClose" & BaseName & Str(j))
  Next
  
  For Each sym In CmdBeforeExec
    If sym <> "" Then CmdFinal &= sym
  Next
  
  For i = CmdList.Max DownTo 0
    If CmdIo[i] <> "" Or CmdErr[i] <> "" Or CmdWrite[i] <> "" Or i > 0 Then 
       Cmdexec[i] &= " For "
       If CmdIo[i] <> "" Or CmdErr[i] <> "" Then 
          Cmdexec[i] &= "Read "
       Endif
       If CmdWrite[i] <> "" Or i > 0 Then CmdExec[i] &= "Write "
    Endif
    
    CmdExec[i] &= "as \"mRead" & BaseName & Str(i) & "\"\n"
    
    If gsh.jobctl Then
         Dim StartCopy As Integer = InStr(CmdExec[i], "''#", 0, gb.IgnoreCase)
         If StartCopy > 0 Then Startcopy += 3 ' len of search string
         Dim EndCopy As Integer = InStr(CmdExec[i], "#''", 0, gb.ignorecase)
         Dim cmdjobsinfo As String = Quote(Mid(CmdExec[i], StartCopy, endcopy - startcopy))
         CmdExec[i] &= "sharedmem[\"pid.p\" & mProc" & BaseName & Str(i) & ".id]= str(mProc" & BaseName & Str(i) & ".id)&\"|\"& format(now,\"mm/dd/yyyy hh:nn:ss.uu\")& \"|\" & " & cmdjobsinfo & "\n"
    Endif
    
    CmdFinal &= CmdExec[i]
  Next
  
  For Each sym In CmdWrite 
    If sym <> "" Then CmdFinal &= sym
  Next
  
  ' bFirst = True
  ' CmdFinal &= "While "
  ' For i = 0 To CmdList.Max
  '   If Not bFirst Then CmdFinal &= " or "
  '   CmdFinal &= "mProc" & BaseName & Str(i) & ".state = process.running" 
  '   bFirst = False
  ' Next
  ' CmdFinal &= "\nwait 0.01\nwend\n"
  CmdFinal &= "mProc" & BaseName & Str(CmdList.Max) & ".wait()\n"
  If Not WaitCompletion Then CmdFinal &= "&"
  Return CmdFinal
  
  Catch
    If gsh.DoTrace Then Error "Function #="; CurrentCmd, Error.text, Error.where
    Error.Propagate()

End

Private Sub preprocess(val As String, Optional NoQuote As Boolean = False) As String
  Select Case val[0]
    Case "\""
      Return Quote(UnQuote(gsh.PreProcesses(val)))
    Case "$"
      If SharedMem.exist(val) Then
          Return UnQuote(gsh.PreProcesses(val))
      Else
          Return Quote(Eval(Mid(val, 2)))
      Endif
    Case "("
          Return gsh.PreProcesses(val)
    Case "{"
          Return "("
    Case "}"
          Return ")"
    Case "@"
      Return Quote(UnQuote(Eval(gsh.PreProcesses(val))))
  End Select
  
  Return IIf(NoQuote, UnQuote(gsh.PreProcesses(val)), Quote(val))
  
  Catch
    Error.Propagate()
End

Private Sub BuildClose(procnum As Integer, processnums As Integer[], BaseName As String) As String
  
  Dim finalbuf As String = "Public Sub mClose" & BaseName & Str(procnum) & "() as boolean\n dim alivecount as integer=0\nDim LastOne as boolean = false\n"
  
  For Each i As Integer In processnums
    finalbuf &= "if mProc" & BaseName & Str(i) & ".state = process.running then inc alivecount\n"
  Next
  
  finalbuf &= "if alivecount = 0 then LastOne = true\nreturn LastOne\nEnd\n"
  Return finalbuf
End


Private Sub SetIoSub(CmdIndex As Integer, basename As String) As String
  Return "mRead" & BaseName & Str(cmdIndex) & "_read|" & "Public sub mRead" & BaseName & Str(CmdIndex) & "_read()\nwith sharedmem\nDim sInput as string\nsInput = read #last, -256\n"
End

Private Sub SetKillSub(CmdIndex As Integer, basename As String) As String
  Dim final As String 
  final = "mRead" & BaseName & Str(CmdIndex) & "_kill|Public sub mRead" & BaseName & Str(CmdIndex) & "_kill()\nwith sharedmem\n"
  If gsh.jobctl Then
    final &= "if sharedmem.exist(\"pid.p\" & mProc" & BaseName & Str(cmdIndex) & ".id) Then "
    final &= "sharedmem[\"pid.p\" & mProc" & BaseName & Str(cmdIndex) & ".id] &= \"|\"& format(now,\"mm/dd/yyyy hh:nn:ss.uu\")& \"|\" & mProc" & BaseName & Str(cmdIndex) & ".value\n"
  Endif
  Return final
End

Private Sub SetErrSub(CmdIndex As Integer, basename As String) As String
  
  Return "mRead" & BaseName & Str(cmdIndex) & "_error|" & "Public sub mRead" & BaseName & Str(CmdIndex) & "_error(msg as string)\nwith sharedmem\n"
  
End

Private syms As String[]
Private types As Integer[]
Private seperators As String[] = [" ", "\t", "\n"]
Private operators As String[] = ["&", "&&", ">", ">>", "<", "&>", "&>>", "|", "||", "!", "{", "}", "|<", "|>", "!>", "&|", "&|<", "&|>"]
Private braces As String[] = ["(", ")"]
Private quotes As String[] = ["\"", "\"", "(", ")", "`", "`"]

'' This function will Parse the LINUX Shell(sh like) command line
Private Sub parseline(InLine As String)
  With sharedmem
  Dim CurrentType As Integer = Highlight.Symbol
  Dim streamPos As Integer = 0
  Dim sym As String = ""
  
  InLine = Trim(InLine)
  
  If InLine[0] = "!" Then Inc StreamPos
  
  syms = New String[]
  types = New Integer[]

  Do
    
    If seperators.Exist(InLine[streampos]) Then
      If sym.len > 0 Then
        FileExpandInsert(sym, CurrentType)
        sym = ""
        CurrentType = Highlight.Symbol
      Endif
      Inc streampos
      Continue
    Endif
    
    If operators.Exist(InLine[streampos]) Then
      If CurrentType <> Highlight.operator Then
        If sym.len > 0 Then
          FileExpandInsert(sym, CurrentType)
          sym = ""
          Currenttype = Highlight.operator
          sym &= InLine[streampos]
          Inc StreamPos
          Continue
        Else
          CurrentType = Highlight.Operator
        Endif
      Else
        If Not operators.Exist(sym & InLine[StreamPos]) Then
          FileExpandInsert(sym, CurrentType)
          sym = InLine[streampos]
          Inc streampos
          Continue
        Else
          sym &= InLine[StreamPos]
          Inc streampos
          Continue
        Endif
      Endif
    Endif
    
    If quotes.Exist(InLine[streampos]) Then ' process quoted strings but include () as quotes as it will be evaluated by gambas at runtime
      If sym.len > 0 Then
        FileExpandInsert(sym, CurrentType)
        sym = ""
      Endif
      CurrentType = Highlight.string
      
      Dim OpenQuote As String = InLine[StreamPos]
      Dim inquote As Integer = quotes.Find(OpenQuote)
      Inc inquote
      If inquote > quotes.max Or If inquote Mod 2 <> 1 Then
          Error.Raise("Unexpected quote/brace \"" & OpenQuote & "\" in >>" & Quote(inLine) & "\n")
      Endif
      
      Dim currentquote As String = quotes[inquote]
      Dim quotelevel As Integer = 0
      Dim InBraces As Boolean = False
      If braces.Exist(OpenQuote) Then 
        Inc quotelevel
        InBraces = True
      Endif
       
      Do
        If InLine[StreamPos] = "\n" Then ' end of line is as good as a close quote
          Break 
        Endif
        
        sym &= InLine[StreamPos]
        
        If InLine[StreamPos] = "\\" Then
          Inc StreamPos
          sym &= InLine[StreamPos]
        Endif
        
        Inc StreamPos
      
        If streampos = InLine.len Then Break
        If InBraces And If InLine[StreamPos] = OpenQuote Then Inc Quotelevel
        If InBraces And If quotelevel > 0 And If InLine[StreamPos] = currentquote Then Dec quotelevel
         
      Loop Until InLine[StreamPos] = currentquote And quotelevel = 0
      
      If QuoteLevel <> 0 Then
         Error.Raise("Missing closing Brace \"" & OpenQuote & currentquote & "\"\n")
      Endif
      
      sym &= currentquote
      
      If OpenQuote = "`" Then 
        Try sym = gsh.PreProcBuffer(Mid(sym, 2, sym.len - 2))
        Try sym = Eval(sym)
        If Error Then
          Error.Propagate()
        Endif
      Endif
      
      FileExpandInsert(sym, CurrentType)
      sym = ""
      CurrentType = Highlight.symbol
      Inc StreamPos
      Continue
      
    Endif
    
    If InLine[StreamPos] = "\n" Or If InLine[StreamPos] = "'" Then Break
    
    If CurrentType = Highlight.Operator Then 
      If Not operators.Exist(sym & InLine[StreamPos]) Then
        FileExpandInsert(sym, CurrentType)
        sym = ""
        CurrentType = Highlight.symbol
      Endif 
    Endif
    
    sym &= InLine[StreamPos]
    Inc StreamPos
    
  Loop Until StreamPos >= InLine.Len 
  
  If sym.len > 0 Then
    FileExpandInsert(sym, CurrentType)
  Endif
  
  For i As Integer = 0 To syms.Max
    If types[i] = Highlight.Symbol Then
       If .Exist("sub." & syms[i]) Then 
         types[i] = Highlight.Function          ' if it is a function it must be defined to at minimum output a string or to input a string or both
       Else If i = 0 And If .exist(syms[i]) Then
             types[i] = Highlight.Label         ' well we need to make it fit in label = system command
       Endif
    Endif
  Next
  
  End With
  
  Catch
   Error.Propagate()
    
End

Private Sub FileExpandInsert(var As String, type As Integer) As Boolean ' return true if we expanded the value

  If type = Highlight.string Then 
    syms.Add(var)
    types.Add(type)
    Return True
  Endif
  
  If var[0] = "$" And If InStr(var, "*") = 0 Then
    Select Case var 
       Case "$$"  ' insert the curent pid
            var = Application.id
       Case "$UID"
            var = User.id
       Case "$GID"
            var = User.group
    End Select
    
    syms.Add(var)
    types.Add(type)
    
    Return True
  Endif
  
  If Not IsGlob(var) Then 
    syms.Add(var)
    types.Add(type)
     Return False
  Endif
  
  If syms.count = 0 Then                                 'this is the command to execute
      Dim files As String[]
     files = DoGlob(var)
      If Files.count = 1 And If files[0] = var Then
          syms.Add(Files[0])
          types.Add(Highlight.added)
         Return False
    Else If Files.count > 1 Then
        Error "To many matches:";; Quote(var); "->"; Quote(files.Join(","))
        Return False
    Else
        syms.Add(Files[0])
        types.Add(Highlight.symbol)
    Endif
  Else
    syms.add("(")
    types.Add(Highlight.Operator)
    syms.Add("fileexpand(" & Quote(var) & ")")
    types.Add(Highlight.custom)
    syms.add(")")
    types.Add(Highlight.Operator)
  Endif
  Return True
  
  Catch
    Error.Propagate()
  
End

Public Sub DoGlob(path As String, Optional dironly As Boolean = False) As String[]
  
Dim Paths As New String[]
Dim sret As New Glob_t
Dim ReturnSet As Pointer
Dim CallResult As Integer


  CallResult = glob(path, (GLOB_TILDE Or GLOB_MARK Or GLOB_NOCHECK Or GLOB_BRACE Or If(dironly = True, GLOB_ONLYDIR, 0)), Null, sret)
  If Callresult <> 0 Then
    Error.Raise("File Expansion Error :" & globerrors[CallResult])
  Endif
  
  ReturnSet = sret.gl_pathv

  For i As Integer = 0 To CLong(sret.gl_pathc) - 1
    Paths.Add(String@(Pointer@(ReturnSet + (SizeOf(gb.pointer) * i))))
  Next
  globfree(sret)
  
Return paths
Catch
  Error.Propagate()
  
End


Public Sub InitAlias()
AliasList = SharedMem["$alias"]
End

Public Sub AliasReplace(Data As String) As String
  'Dim bChanged As Boolean = False
  
  'Dim aList As String[] = Split(Trim(data), " \t!|", "\"\"", True, True)
  Dim s As Variant
  Dim used As New String[]
  
  'If Upper(aList[0]) = "ALIAS" Then Return data
  If Upper(Left(Trim(data), 5)) = "ALIAS" Then Return data
  
DoAliasAgain:
  For Each s In aliaslist
    Dim akey As String = aliaslist.key
    If Not used.Exist(akey) Then
      If InStr(aKey, "()") > 0 Then
        'If MyReg.Match(data, "^.*" & Left(aliaslist.key, aliaslist.Key.len - 1) & "([(]+.*+[)])") Then 
        MyReg.compile("^.*" & Left(aKey, aKey.len - 2) & "([(].*[)])", RegExp.MultiLine)
        MyReg.Exec(data)
          If MyReg.Count > 0 Then
            'Print MyReg[0].text
            Dim params As String[] = Split(MyReg[0].text, "(,)", "\"\"", True, True)
            MyParams = New String[20]
            For i As Integer = 1 To IIf(params.max - 1 > MyParams.Max, MyParams.Max, params.max)
              MyParams[i - 1] = params[i]
            Next
            data = Replace(data, MyReg[0].text, Subst(s.Join(" ") & " ", MyParams[0], MyParams[1], MyParams[2], MyParams[3], MyParams[4], MyParams[5], MyParams[6], MyParams[7], MyParams[8], MyParams[9], MyParams[10], MyParams[11], MyParams[12], MyParams[13], MyParams[14], MyParams[15], MyParams[16], MyParams[17], MyParams[18], MyParams[19]))
          Endif
        
      Else If aliaslist.key = Trim(data) Then 
          data = s.Join(" ") & " "
          
      Else If RegExp.Match(data, "^" & akey & "[ <>|!&\n\t]") Then 
          data = RegExp.replace(data, "^" & aKey & "[ <>|!&\n\t]", s.Join(" ") & " ")
          used.Add(aliaslist.key)
          Goto DoAliasAgain
          
      Else If RegExp.Match(data, "[ !|><&]" & akey & "[ <>|!&\n\t]") Then
          data = RegExp.replace(data, "[^!| ]" & aKey & "[ <>|!&\n\t]", s.Join(" ") & " ")
          used.Add(akey)
          Goto DoAliasAgain
      Endif
    Endif
  Next
  
  If InStr(data, "::") <> 0 Then
      used = parser(data)
  
      If used.count > 1 Then
        For i As Integer = 1 To used.Max
          gsh.ReadQueue.Enqueue(used[i])
        Next
      Endif
      Return Trim(used[0])
      
  Else
     Return Trim(data)
  Endif
  
  Catch
    Error.Propagate()
End


Public Sub alias(cmd As String) As String[]  ' return a list of command line changes

Dim result As String[]
  
result = AliasList[cmd]

If IsNull(result) Then 
   result = New String[]
   result.Add(cmd)
Endif

Return result
End

Public Sub setalias(cmdline As String)
  
  Dim body As String[]
  Dim cmd As String[]
  Dim Params As String[]
  
  
  cmd = Split(cmdline, " =", "''", True, False) 
 
  If cmd.count = 2 Then
      params = Split(cmd[1], "()")
      If params.count > 1 Then cmd[1] = params[0] & "()"
      If aliaslist.Exist(cmd[1]) Then aliaslist.Remove(cmd[1])
  Else
      If cmd.count <> 3 Then
       Error.Raise("Not enough info to define alias '=' is missing: " & cmdline)
      Endif
      params = Split(cmd[1], "(),", "\"\"")
      If params.count > 1 Then
        cmd[1] = params[0] & "()"                                   ' set up the alias so we match a bracket
      Endif
      
      body = Split(cmd[2], " \t", "", True)
      
      If body.count < 1 Then 
        Error.Raise("alias: no definition provided: " & cmdline)
      Endif
  
      If Not aliasList.exist(cmd[1]) Then
         aliasList.Add(body, cmd[1])
      Else
          aliaslist[cmd[1]] = body
      Endif
  Endif
  
  SharedMem["$alias"] = aliasList
  
  Catch
    Error.Propagate()
    
End

Public Sub listAlias(Optional sAlias As String = "")

If sAlias <> "" Then 
    Dim params As String[] = Split(sAlias, "()")
    If params.count > 1 Then sAlias = params[0] & "()"
    If AliasList.exist(sAlias) Then
      printAlias(sAlias, AliasList[sAlias])
      Return
    Else
      Error.Raise("Unknown alias :" & sAlias)
    Endif
Endif

Dim sortlist As New String[]
Dim MaxLen As Integer = 0
For Each s As String[] In AliasList
  sortlist.Add(AliasList.key)
  If AliasList.Key.len > MaxLen Then MaxLen = AliasList.Key.len
Next

sortlist.sort()

For i As Integer = 0 To sortlist.max
  If sortlist[i][sortlist[i].len - 1] = "(" Then
    AliasList.Remove(sortlist[i])
    SharedMem["$alias"] = aliasList
    Continue
  Endif
  printAlias(sortlist[i], AliasList[sortlist[i]], MaxLen)
Next
  
End

Public Sub printAlias(name As String, def As String[], Optional MaxNameLen As Integer = 20)
  Dim bFirst As Boolean = True
  
  Print "\x1b[32m" & Left(name & Space(MaxNameLen), MaxNameLen) & "\x1b[0m"; " = '";
  For Each s As String In def
    If Not bfirst Then Print " ";
    Print s;
    bfirst = False
  Next
  Print "'"
  
End































