#Buffer

C
RootAddress
p
p

'Most properties are set by the creater of the buffer
RelativeAddress
p
p

StorageLength
p
i

SymbolName
p
s

DataType
p
i

CreatedByMe
p
b

Parent
p
o

oShm
p
v

Fields
p
Collection

Methods
p
Collection

BytesUsed
p
i

Len
m
i

SupportedDataTypes
p
Integer[]

_new
m

[(vshm)v(BufLength)i(SymName)s(BufType)i]
'The only creation input to this is the actual shared memory segment used
'The rest are assigned after the creation of this buffer
Create
m
p
(symbol)s(iLen)i[(rdType)i]
'Create a shared memory segment to contain this buffer
Define
m
BufferFields
(ElementName)s(ElOffset)i(ElLength)i[(ElType)i]
_property
m
b
.
_Unknown
m
v
.
_get
m
v
(index)i
_put
m

(Data)v(index)i
_read
m

(mFile)File;
'This function reads an object definition from the provided
'open input stream, the first integer must be the length
'of the object
Read
m
p
[(mFile)v(start)i(ilength)i]
_write
m

(mFile)File;
Write
m
i
[(mFile)v(start)i(ilength)i]
Access
m
p
(symbol)s[(rdType)i]
Release
m
b

CopyTo
m
p
(dest)p(index)i(length)i
CopyFrom
m
p
(src)p(index)i(length)i
FillMem
m

(Value)i[(index)i(length)i]
Duplicate
m
Buffer
(symbol)s
Compare
m
i
(src)p(length)i[(Offset)i]
Equal
m
b
(src)v[(length)i(Offset)i]
Less
m
b
(src)v[(length)i(Offset)i]
Greater
m
b
(src)v[(length)i(Offset)i]
_VarLen
m
i

_VarPtr
m
p

_call
m
p

_print
m


#BufferFields

C
Offset
p
i

Length
p
i

DataType
p
i

name
p
s

ParentBuffer
p
Buffer

_new
m

(SourceBuffer)Buffer;[(FieldName)s(FieldOffset)i(FieldLength)i(FieldType)i]
_print
m
s

_call
m
v
.
_get
m
v
.
_put
m

(value)v.
#Element
Buffer
C
#ServiceTask
Task
C
BufferName
v
s

ErrBuff
v
s

HostName
v
s

Port
v
i

Password
v
s

shmName
v
s

BlockSize
v
i

$oShm
v
SharedMem

main
m


Service_errdata
m

(buffer)Byte[];(len)i
Service_indata
m

(buffer)Byte[];(len)i
Service_kill
m

(data)i
#SharedClass

C
'This class must be inherited if classes which will be shared between tasks/processes
'If you do not use this class as the default then your non data usage class will fail
'when you try to save of load from the shared memory database
'or you can just define the _read and _write functions in your shared object class
'Inheriting this will at least save and create a new class every time, No Data saved
classversion
C
i
1
'This must be defined for any storable class
'it is used to verify the version of a stored object
TypeToText
V
String[]

_new
m

[(LoadFrom)v]
'This is called whenever the object is created
'Can be just created no information
'Can be created from a stream
'Can be created from a pointer
_read
m

(mFile)File;
'This will find every property of the object and try
'to read from the stream for any valid properties
'Note: remember formats to a buffer ie memory stream
'      are not the same as to a file stream
_free
m


'This is called whenever the object is destroyed
_write
m

(mFile)File;
'This will find every property of the object and try to\
'write it to the output stream
'Note: remember formats to a buffer ie memory stream
'      are not the same as to a file stream
_serialize
m
i

'This will return the length of storage required by the object
_compare
m
i
(OtherObject)v
'Compares two objects and verifies if the version is the same
'it will throw an error if the object versions are not comparable
ToString
m
s

'returns a printable text representation of the object
'Does not include functions etc only data
GetObjectVersion
m
i

_convertObject
M
b
(OtherObject)v
'does the conversion to the new format and returns the new object
'returns a copy if no conversion required
#SharedMem

C
'This Class provides a way to manage and access memory which may be shared between Tasks\
'It provides Safe access to defined variables used between Tasks.
'
'This means that Semaphors are used to syncronize events between tasks\
'Signal call backs when variables are changed are also provided.\
'Two levels of access are provided through the mem class direct unprotected access
'And through this class protected access.\
'Defined variables become are dynamic type at the time of creation and become fixed when
'a notification of change is requested may not change type until the notification is cancelled.\
Version
R
s

MemSigConst
V
i

Repeat
C
i
-1
'Notify every time value changes
Once
C
i
0
'Notify app once when value changes
DataTypes
V
String[]

MemoryAddress
V
p

CollectMemLen
V
i

SymbolTable
V
Collection

'Collection of the Symbols defined in the Shared Memory Area
DefaultSaveLocation
V
s

LastMemorySync
V
s

NamedMemHandle
V
i

NamedMemName
V
s

NamedMemCollectionHandle
V
i

UserMem
V
Mem

ColMem
V
Mem

Count
R
l

Vars
R
Collection

key
P
s

length
M
i

'returns the length of the symbol table\
'ie number of entries
SharedMemoryControlHeader
V
i

'length of Shared memory header
SharedMemoryControlLength
V
i

AllocHeaderLen
V
i

'Length of shared Allocation Variable block header
LenOffset
V
i

'Offset in header of the block length
WaitOffset
V
i

'Offset in header where a count is kept of accessors wait on change
LastWriteOffset
V
i

'Offset in header where the last write time is updated when needed for wait
DataOffset
V
i

'Offset of the actual data in the buffer
ArrayDefOffset
V
i

'Offset for array type in data area of array def bytes
ArrayLenOffset
V
i

'Offset for array length spec in the memory block
ShmTypeStd
C
i
0
'Types Of entries In the Symbol Collection \
'ShmTypeStd Standard Memory with access through MEM\[\] or SharedMem\[\]\
'ShmTypeAry Array Type of access with index SharedMem["xx",4] for element , or whole array SharedMem["xx"] \
'ShmTypeBuff Binary Buffer. A block of memory refrenced Via Binary style MyBuff[3] one byte at a time, or type specifies at creation \
'ShmTypeElement Pointer into buffer is a pointer into a part of memory MyElement[3] element as defined as creation or default Byte\
'> This type of pointer may also be refrenced via protected interface SharedMem["xx"]
ShmTypeAry
C
i
1
'Types Of entries In the Symbol Collection \
'ShmTypeStd Standard Memory with access through MEM\[\] or SharedMem\[\]\
'ShmTypeAry Array Type of access with index SharedMem["xx",4] for element , or whole array SharedMem["xx"] \
'ShmTypeBuff Binary Buffer. A block of memory refrenced Via Binary style MyBuff[3] one byte at a time, or type specifies at creation \
'ShmTypeElement Pointer into buffer is a pointer into a part of memory MyElement[3] element as defined as creation or default Byte\
'> This type of pointer may also be refrenced via protected interface SharedMem["xx"]
ShmTypeBuf
C
i
2
'Types Of entries In the Symbol Collection \
'ShmTypeStd Standard Memory with access through MEM\[\] or SharedMem\[\]\
'ShmTypeAry Array Type of access with index SharedMem["xx",4] for element , or whole array SharedMem["xx"] \
'ShmTypeBuff Binary Buffer. A block of memory refrenced Via Binary style MyBuff[3] one byte at a time, or type specifies at creation \
'ShmTypeElement Pointer into buffer is a pointer into a part of memory MyElement[3] element as defined as creation or default Byte\
'> This type of pointer may also be refrenced via protected interface SharedMem["xx"]
ShmTypeElement
C
i
3
'Types Of entries In the Symbol Collection \
'ShmTypeStd Standard Memory with access through MEM\[\] or SharedMem\[\]\
'ShmTypeAry Array Type of access with index SharedMem["xx",4] for element , or whole array SharedMem["xx"] \
'ShmTypeBuff Binary Buffer. A block of memory refrenced Via Binary style MyBuff[3] one byte at a time, or type specifies at creation \
'ShmTypeElement Pointer into buffer is a pointer into a part of memory MyElement[3] element as defined as creation or default Byte\
'> This type of pointer may also be refrenced via protected interface SharedMem["xx"]
DoInit
M


_init
M


MREMAP_MAYMOVE
C
i
1
MREMAP_FIXED
C
i
2
_print
M

[(ShortForm)b]
'Prints the contents in detail of the Shared memory
NotifyCancel
M

(Symbol)s(NotifyObject)o
'This Method is used to cancel the notification sent when memory changes\
'Symbol is the name in the Symbol table\
'NofifyObject id the Object which is waiting for a notification
NotifyChange
M
b
(Symbol)s(NotifyObject)o[(iTimeOut)l(FunctionName)s]
'This Method requests a notification when the content of a shared memory Symbol/Variable changes\
'Notification can be requested by any task started from the primary task, any onject or number of objects in any task\
'may request to be notifies when a Shared Memory variable chnages value\
'
'Symbol is the text name of the Variable your want to be notified when it changes\
'NoifyObject is the object where the change method will be called when the requested Variable changes\
'iTimeout is the timeout period when waiting for a SharedMemory Variable to change\
'> 0 is a one shot notification, the object will recive a message when the variable changes only once\
'> -1 the object is notified everytime the Variable changes\
'> any value greater than zero, the object is notified any time before the timeout expires
NotifyList
M
String[]

'Get a low level list of all symbols in the notify queue
NotifyWaiting
M
String[]

'Get a list of the high level sysmbol count of waiting pids
Add
M

(LSymbol)SharedMemSymbol;
'add a symbol to the symbol table
Begin
M
b
[(blockSize)v]
'This Method must be called before any Shared memory Variable is created\
'It May be called in two ways
'
'> With a value eg SharedMem.Begin(23456) this will allocate 23456 bytes of memory,\
'>  > And when used up will allocate another block this size .. etc
'
'> With a file name eg SharedMem.Begin("/home/xx/memstore/thismem")\
'> > This will read the information about the last session and using that information\
'> > will recreate the full environment from the last call to ShareMem.end("filename")\
'> > All Shared Memory Variables are restored and available. Notify requests are of course not\
'> > Restored.\
'if SharedMem.Begin() is specified as the file name the name is generated automagically\
'> format: user.home & "/var/" & Application.name & ".mem"
_read
M
b
(MFile)File;[(iMerge)b]
'when the entire shared memory is to be loaded\
'this may be called, or to merge information to current shared memory
BeginNamed
M
b
[(MemName)s(MemSize)i(forceCleanup)b]
'This function creates a named shared memory space see Begin above for details\
'If you want to load a symbol table from disk then use Merge after this call
ClearMem
M


'this function clears the memory and deletes all the variables
Exist
M
b
(Symbol)s
'Return true if the names variable exsists
Free
M
b
(symbolKey)s[(bLock)b]
'free a variables storage and move the block to the free list
Merge
M
b
[(FileName)s]
'Loads a file containing a memory image into memory
'merging the variables from that image with the current Shared Memory Storage
'Duplicate variables will be replaced with the new value.
Sync
M
b
[(Symbol)s(FileName)s]
'Sync the content of memory with the last loaded file or write to default file storage
'this will update the file with the memory content or create and write the default file
'with no parameters syncs all of memory, with symbol, syncs the variable to disk
WriteVarTo
M
i
(Symbol)s[(FileName)v(bsync)b]
'This allows a variable to be stored to a file
'by default if no file is specified then The variable is written to users home directory/vars/varname
'the entire context of the variable is stored, for loading at a different time
_write
M
b
(MFile)File;
'When the entire SharedMem is to be stored \
'this may be called.
Restore
M
b
[(Symbol)s(FileName)s]
'Restore the content of memory with the last saved file or read to default file storage
'this will update the memory with the file content or read the default file
'with no parameters restores all of memory, with symbol, restores the variable to shared memory
'. means all Memory
ReadVarFrom
M
i
(Symbol)s[(FileName)v(bsync)b]
'Reads a variables context and value from a file\
'the context is first read, then the storage is allocated and SharedMemSymbol is created if\
'it is not allready defined, if it is already defined it is freed then reallocated\
'the saved value of the variable is then loaded\
'The Variable value may be loaded into a diffrent variable name by specifiing the filename as other then default\
'> SharedMem.ReadVarFrom("MyVar") <- reads from file of this name\
'> SharedMem.ReadVarFrom("MyVar","TheOtherVar") <- reads from the content of a var called MyOtherVar
end
M

[(FileName)s]
'This Method is used to close and free Shared Memory\
'This method has two forms
'> SharedMem.End()  which simply releases the shared memory resets all\
'> > Tables etc.
'> SharedMem.end("Filename") This stores the full state of the shared\
'> > memory block to the file. All states and information are preserved.\
'> if "." is specified as the file name the name is generated automagically\
'> format: user.home & "/var/" & Application.name & ".mem"
Element
M
Element
(RootVar)v(Symbol)s(index)i(DataType)i[(ilen)i]
'Creates an element/pointer to an area within a variables area of memory\
'it return an Element which need not be used.\
'The refrenced pointer may be used in two ways:\
'> Through the returned Element object which is not locked during access.\
'> MyElement[0] or as SharedMem["TheElement"] which is locked during access\
'> > MyElement = SharedMem.Element(\[BufferObject | "VariableName"\], "TheNameWeGiveOurPointer", 0, Sizeof(gb.long), gb.Long)\
'> > MyElement\[0\] = 20 ' Unprotected - No Semaphor lock during the data change.\
'> > or\
'> > SharedMem\["TheNameWeGiveourPointer"\] = 20 ' Protected - Uses Semaphor lock during the data change.\
'> >
_Symbol
M
SharedMemSymbol
(Symbol)s
'Returns a Sombol table entry SharedMemSymbol
NamedAlloc
M
p
(Symbol)s(MemSize)i(MyObject)v
'Create a named block of memory or one which is given a variable name and can be locked during update or read opertation\
'Symbol is the name which the memory block will have\
'Memsize is the size of the memory to allocate\
'the object will have its own information manager for its content
ShmAlloc
M
p
(MemSize)i
'Allocate an unprotected block of memory
ShmFreeChk
M
p
(DataSize)i
'returns a block of the size requested from the free list if available
ShmFree
M

(MemoryPointer)p
'Free an unprotected block of memory
ListFreeBlocks
M
Pointer[]

ListAllBlocks
M
Pointer[]

'Returns a list of all memory blocks allocated from the Shared Memory area
ListFreeBlockLen
M
Integer[]

'returns a list of all sizes of the free blocksfreelen) in the free block list
_get
M
v
(index)s.
'Get the value of the variable from the shared memory\
'forms are \
'Sharedmem["MyVar"] or for arrays SharedMem["MyVar",6] <- includes the array index\
'The Data Type of the variable is defined by the first use of the variable
Rename
M

(Symbol)s(newname)s[(force)b]
'Rename a variable from one name to another
_put
M

(data)v(index)v.
'Set the value of a shared memory variable\
'Forms are\
'x = SharedMem["MyVar"] or x = SharedMem["MyVar",6] <- index into an array type value
DumpMem
M

(mPointer)p(IntLength)i[(FileName)s]
'a function which may be called to dump the content of any memory area to a file
'The default location if no name specified is the users desktop as dumpfile
used
M
i

'returns the amount of memory in the Shared memory block that has been used
_varptr
M
p
(Symbol)s
'Returns a pointer to the datastorage area of the variable
RealAddress
M
p
(Symbol)s
'Returns the real mapped address of the variable
'note this will change so should be called right before use
'unless you know that the memory block will not change between
'As in a buffer of fixed value
PhysicalAddress
M
p
(OffsetAddress)p
_varLen
M
i
(Symbol)s
'Returns the length of the data storage block of the array
Len
M
i
(Symbol)s
'Same as _varlen, returns the length of the datastorage of the variable
AsObject
M
v
(Symbol)s
'returns the SymbolTable entry for simple variables\
'returns the managing object for Buffer(named memory blocks) and elements(pointers inside named blocks)
GetVarByAddress
M
s
(Addr)l
PrintSummary
M


_serialize
M
i

'This return the total amount of space required to store the\
'symbol table to a file
write
M
i
(wFile)File;(Symbol)s[(ilength)i]
'write the data value to a stream
'this will write directly no context and only the raw data
read
M
i
(rFile)File;(Symbol)s[(ilength)i]
'This will read directly from the file or stream into the data store without destroying the data type or other context information
'raw data is dumped into the shared memory area
VariableList
M
s

'This function returns a list of comma seperated variable names
Variables
M
String[]
[(filter)s]
SetDefaultDirectory
M

(LocationName)s
'This will set the default storage location for saved variables and Whole shared memory blocks
isActive
M
b

'Returns true if Shared Memory has been allocated
_property
M
b
.
'Named interface for variables
_unknown
M
v
.
_next
M
v

'This returns a sorted  enumerated list of current variable names
'it is a snap shot of the variables at the time the started
'user should verify the names exsist before accessing them
#SharedMemSymbol

C
SymName
v
s

$oShm
v
v

SpecialType
v
i

SpecialObject
v
v

ParentRootAddress
v
p

LastMemorySync
v
s

ClassName
v
s

SymType
v
i

ObjectName
v
s

ElementCount
v
i

ElementType
v
i

RootAddress
v
p

DataAddress
v
p

ShmWait
v
p

ShmLastWriteTime
v
p

storageLength
v
i

dataLength
v
i

LastWriteLength
v
i

StringBufferExtra
C
i
1024
ZeroPointer
v
p

ZeroRef
v
p

RootRef
v
p

UnsupportedList
v
String[]

Value
p
v

LastWriteTime
r
f

Length
r
i

_new
m

[(vshm)v]
_write
m

(mFile)File;[(WithData)b]
'Write the variable def  to the and format information to an output file
'Optionally write the variables value as well
_serialize
m
i
[(WithData)b]
'This returns the total amount of space required to store the\
'symbol to a file
_read
m

(mFile)File;[(WithData)b]
'Read a variable def And control information From an Input file
'Optionally load the data as well in to the shared memory
AllocStorage
m
b
(iLength)i
updateobjectinfo
m

(data)v
SetSymbol
m
b
(Sname)s(data)v[(extrastorage)i]
ShmWrite
m
i
(mdata)v
_wait
m
i

SetLastWrite
m
f

_waiting
m
b

GetWaitCount
m
i

_ClearWait
m
i

getLastWrite
m
f

SetStorage
m
b
(data)v[(ExtraLen)i]
Serialize
m

(data)v
ShmRead
m
v

ShmReadSub
m
v
.
ShmElementAddress
m
p
(index)i
ShmWriteSub
m

(data)v.
DataPtr
m
p

'object or string or base data types
DataOffsetPtr
m
p

ShmCopy
m

(mempointer)p(memlen)i
_call
m
v
[(Value)v]
_get
m
v
.
_put
m

(Value)v(index)i
memSize
m
i

SizeOf
m
i

SetZeros
m


AddressPtr
m
p

'basic information And pointer To storage For strings, And objects
DumpMem
m


'Dumps the variables value to an output file
_print
m


'Prints the details of this variable to the current output sink
#SharedMemWaitQueue

C
ChangeSignal
C
i
16
$oShm
v
v

GetWhoWaiting
m
s
(sym)s
'return a printable list of objects waiting for a notification of value change
NotifyList
m
String[]

NotifyCancel
m

(Symbol)s(NotifyObject)o
'timeout can be  = 0 = wait forever until first occurance          call _change
'                < 0 = notify me everytime a location changes      call _change
'                > 0 wait for timeout and                          call _nochange
'call function names can be overridden by providing function name
'waiting for a timeout is very slow and you must execute a wait in your bg task to dispatch the timeout
_new
m

[(vshm)v]
reset
m


_begin
m


'we will allocate a fixed table of pids to be used for notification
Dofree
m


'Remove the Application from the list of applications waiting for a notification
_signal
m

(sig)i
'signal handler for waiting applications
dispatch
m


'Dispatch the signal to each application waiting for a change in the variable
NotifyChange
m
b
(Symbol)s(NotifyObject)v[(iTimeOut)l(FunctionName)s]
'Place an entry into the list of applications waiting to be notified of a change in a variable
#SharedRemote

C
:errdata
:

(data)Byte[];(len)i
:indata
:

(data)p(len)i
:Kill
:

(data)i
_new
m

(host)s(password)s[(port)i(Verbosity)i]
_free
m


ExecuteCommand
m

(command)s
OpenShell
m
i
(WriteBuff)s
ShellLink
m

(WriteBuff)s
#ShmBuffer

C
cShmBuffer
V
i

'The Constant identifying this class name must not be a valid datatype integer
cShmBufferEntry
V
i

'The entry in a Buffer Element index object type
Data
r
p

'Return the real address data portion of the Buffer
Length
r
l

'The Length of the Data Portion of the buffer
Count
r
l

'Returns the length of data portion of the  buffer in bytes
Fields
r
Collection

'Returns the collection of fields elements in the buffer
Dim
r
l

'count of specified dimentions  count, uses pointer to be unsigned
Bounds
r
Long[]

'return an array containg the bounds for the array, length Dim elements
SetHeadType
v
i

'The Buffer  header Class
SetEntryType
v
i

'The Buffer Entry Class
_init
M


_new
m

(Shm)ShmMem;(ElementLengthDef)v[(ArrayDef)Long[];]
'Pass in the Shared memory object where the buffer will be allocated
'Then pass in the Length of the buffer required, if not specified then it will
'be the sum of all fields allocated, which must be specified when the, buffer is created.
'Then any number of array subscripts may be specified 0..n eg [1,4,78,2]
'Example a = new ShmBuffer(MyShm,2000,[2,100]) creates a buffer with 2x100 entries of 2000 bytes
'                  a = new ShmBuffer(MyShm,[ ["Entry1":sizeof[gb.integer] , ["entry2":Sizeof(gb.Long)] ],[2000])
'                  creates a buffer with two fields in an array of 2000 entries of that structure
'                  a = new ShmBuffer(MyShm,1000000)  creates a buffer of 1meg
Define
m

(Element)s(ElementLength)i.
'define the element must provide the offset for root array element
_free
m


_property
m
b
.
_unknown
m
v
.
_put
m

(Value)v.
'Indexes are always in the form of bytes/field elements if more that one dimension
_get
m
v
.
#ShmBufferField

C
DataType
p
i

Offset
p
p

Length
p
p

Buffer
p
ShmBuffer

Name
p
s

_new
m

(oBuffer)ShmBuffer;(Element)s(ElementOffset)p(ElementLength)i
_free
m


#ShmFiFo
ShmList
C
_init
M


_new
m


Push
m

(Value)v
Pop
m
v

#ShmFiFoEntry
ShmListEntry
C
#ShmFiLo
ShmList
C
_init
M


_new
m


Push
m

(Value)v
Pop
m
v

#ShmFiLoEntry
ShmListEntry
C
#ShmList

C
'Defines the Shm datatype - list
'Lists are inherited by every other list based object
Address
r
p

'The address of the object
Type
r
i

'The type of this object
Value
r
l

'Returns the virtual address of this list
cShmList
V
i

'The Constant identifying this class name must not be a valid datatype integer
cShmListEntry
V
i

'The entry in a ShmList object type
ListHead
v
dList

'Pointer to the actual list
VarMem
v
ShmVarStorage

'The storage pool to used or referenced
Key
v
l

'During iterations this will be the item count
max
r
l

'max count for iteration
count
r
l

'Count of elements in this list
Debug
p
b

'Debugging helper
AllLists
r
Variant[]

'Returns a table of all active List{type} in memory
SetHeadType
v
i

'The list header Class
SetEntryType
v
i

'The List Entry Class
_init
M


_new
m

(VarStorage)v[(VirtAddress)p(GlobalValue)b]
NewEntry
m
dList
[(Value)v]
_Free
m

[(OverRideGlobal)b]
Free
m


'Free the entire list
EntryPtr
m
dList
(VirtAddress)p
add
m

(Value)v
_Assign
m

(VEntry)dPointer;
AsDListList
m
DList[]

Clear
m


_get
m
v
(Index)i
_put
m

(Value)v(Index)i
insert
m

(Index)l(Value)v[(priority)i]
remove
m
v
[(Index)l]
RemoveByVirt
m
v
(VirtAddress)p
Copy
m
v

_next
m
v

#ShmListEntry

C
Address
r
p

'The virtual address of the entry
Type
r
i

'The Type of this block
Value
p
v

'The actual value of the entry
RefCount
r
l

'The Number of refrences or used as a tag/priority field
Debug
p
b

_new
m

(VarStorage)v[(VirtAddress)p]
NewEntry
m
dList
[(Value)v]
#ShmManage

C
Debug
p
b

Storage
v
ShmMemBlock

Length
r
l

ManagedInfo
v
InfoHeader

Count
r
l

MAX
r
l

Key
r
s

Used
r
l

Available
r
l

_new
m

(MemBlock)ShmMemBlock;[(CreateManagement)b]
AllocPtr
m
AllocHeader
(VirtAddress)p
RealAddress
m
p
(VirtAddress)p
'Returns a real pointer to the actual address of the allocated address block
RealDataAddress
m
p
(VirtAddress)p
Alloc
m
p
(DataLen)l
'returns a virtual memory address
_Print
m

[(vVarStorage)ShmVarStorage;]
free
m

(VirtAddress)p
_PrintFreeList
m


_PrintBlocks
m

[(vVarStorage)ShmVarStorage;]
_PrintInfo
m


DumpMem
m

(mPointer)p(IntLength)i[(Filename)s]
'a function which mat be called to dump the content of any memory area to a file
'The default location if no name specified is the users desktop as dumpfile
DumpAllMem
m


'Dump all the memory for this mem object
DumpVirt
m

(VirtAddress)p(Length)i
'Dump a section of virtual memory
_get
m
v
(Block)s
_next
m
v

#ShmMemBlock

C
Debug
p
b

name
v
s

'Name used for this memory block, blank if unnamed
length
r
l

'Length of user space
MemoryLength
v
l

'Length of actual allocated memory
MemoryBlockSize
v
l

'The size of memory used to extend this if needed
LockTimeOut
v
f

'The length of time before reporting race condition
DataAddress
v
p

'The address of memory usable by the application
DataLength
v
l

'Length of user accessable area
DefaultLength
C
l
4000000
'Default length of allocated chunk of memory 4Meg
MemoryHandle
v
i

'Handle of named shared memory segment
MemoryAddress
v
p

'Real memory address of this shared memory
BlockInfo
v
MemBlockHeader

'The information stored in the header of the memory
address
r
p

'address of user space
_print
m


ForceDelete
M

(SharedName)s
_new
m

[(SharedLength)l(SharedName)s(WaitTimeout)f(cleanup)b]
MapMemory
m
p
(BlockSize)l
'Map a block of named or unnamed memory into the address space of the app
CreateNamedMem
m
p
[(MemName)s(MemSize)i(forceCleanup)b]
'Allocate the block of named memory right away
RemapNamed
m

(NewLength)l
'Called to have the mapped area match the actual shared area
_free
m


Exclusive
m


ExclusiveTimeout
m


Release
m


AllocChunk
m


#ShmNotify

C
'Defines the Shm datatype - list
'Lists are inherited by every other list based object
ChangeSignal
C
i
16
'Sigsys = 31, SigUSr2 = 12, sig16 is unused too
_New
m

(VariableMemory)ShmVarStorage;
'Create a new notify queue for this symbol table
'This is called by the Symbol table to create the notify queue
_free
m


_signal
m

(sig)i
'Signal handler for user defined signal
Notify
m

(SymEntry)Symbol;(CallBack)o(CallFunc)s[(timeout)l]
'Timeout of zero means wait for ever
VarInfo_VarTimedOut
m

(VarInfo)ShmNotifyEntry;
VarInfo_VarChanged
m

(VarInfo)ShmNotifyEntry;
NotifyStop
m

(SymEntry)Symbol;
SignalEach
m

(Sym)Symbol;
'Called by the symbol table when ever a variable changes value
'This only supports variables not direct memory values
#ShmNotifyEntry

C
NotifyObject
v
o

NotifyFunc
v
s

NotifyTimeout
v
i

NotifyVar
v
Symbol

VarName
v
s

VarMemory
v
ShmVarStorage

StartTime
v
f

:VarChanged
:

(VarDef)ShmNotifyEntry;
:VarTimedOut
:

(VarDef)ShmNotifyEntry;
_new
m

(SymName)Symbol;(CallObject)o(CallFunc)s(VarMem)ShmVarStorage;[(fTimeout)l(Once)b]
'Dispatch Functions must look like
'MyChange(SymSource as ShmMem, SymName as String, Value as Variant, TimedOut as boolean)
VarTimeOut_Timer
m


NewVal
m


Dispatch
m

(Failed)b
#ShmQueue
ShmList
C
_init
M


_new
m


Push
m

(Value)v
Pop
m
v

EnQueue
m

(Value)v[(Priority)i]
DeQueue
m
v
[(Priority)i]
Exist
m
b
(Priority)i
_next
m
v

#ShmQueueEntry
ShmListEntry
C
Priority
r
l

#ShmSymbolTable

C
Count
r
i

'The number of active entries in the symbol table
Collisions
r
i

'The number of time the Hash Function Collided with used entry
SymTblMem
v
ShmMemBlock

VarMem
v
ShmVarStorage

NotifyVars
v
ShmNotify

SymMem
v
tableLayout

SymInfo
v
TableInfo

text
r
s

'Returns a printable representation of the symbol table
Length
r
i

'The number of active entries in the symbol table
Max
r
i

'The highest index that will work
Key
r
s

'The key when using for each
Default
p
v

'The default value returned when a symbol does not exist, Defaults to False
MaxSymbols
r
i

'The Max number of symbols that can be placed in the table
MaxUsedSymbols
r
i

'Highest Number Of Symbols ever used
Debug
p
b

Save
m

(OutFile)File;
WriteVar
m

(Address)l(OutFile)File;(SymName)s
SaveVar
m

(SymName)s(OutFile)File;
exist
m
b
(SymName)s
Load
m

(InFile)File;
LoadVar
m

(InFile)File;[(SymName)s]
ReadVar
m

(InFile)File;(ReqSymname)s
_put
m

(Value)v(SymName)s
SymbolLength
M
i

InfoLength
M
i

_new
m

(MemBlock)ShmMemBlock;(DataMem)ShmVarStorage;
_free
m


Clear
m


Add
m
l
(SymName)s(Value)v
'Return the slot number insert the name and change the lastupdated time
'Create a basic variable storage to go along with this symbol
'Update the virtual address of Var in the table
GetSymIndex
m
p
(Symbol)s
Copy
m

(SymbolName)s(NewName)s
'Copy Value to new variable
'Creates a copy of the variables value and then
'Creates a new variable or assigns the value of the given name
_get
m
v
(SymName)s
Rename
m

(SymbolName)s(NewName)s[(force)b]
'Rename the symbol to a new name
'allow to force rename to new name even if exists
Remove
m

(SymName)s
Notify
m

(SymName)s(CallBack)o[(FuncName)s(Timeout)l]
NotifyStop
m

(SymName)s
VarPtr
m
v
(SymName)s
'Returns the Virtual Address of the symbol
Entry
m
v
(SymName)s
WaitFor
m
b
(SymName)s[(Timeout)f]
'Wait for a variable to appear with timeout
WaitForValue
m
b
(SymName)s(Value)v[(Timeout)f]
WaitValueChange
m
b
(SymName)s(Value)v[(Timeout)f]
SortedList
m
String[]

_next
m
v

#ShmVarStorage

C
DefaultAlloc
V
i

'Default increments used when allocating string and object memory
VariantHeaderLen
V
i

'Define the max size of a class name for this useage
Length
r
i

UserClasses
V
Collection

UserClassByName
V
Collection

DataTypes
V
String[]

Key
r
s

Count
r
i

Max
r
i

Debug
p
b

DefineClass
M

(ClassName)s(ClassIndex)i
GetTextType
M
s
(Type)i
_new
m

(mem)ShmManage;
'Creating this pool of variable storage for a specific memory block
_free
m


Alloc
m
p
(Length)l
AllocVirt
m
p
(Length)l
set
m
p
(Value)v[(VirtAddress)p]
'set the value of a variable, create a new one if VirtAddress is zero
_put
m

(Value)v(VirtAddress)p
Getpointer
m
v
(Type)i(VirtAddress)p
RealAddress
m
p
(VirtAddress)p
_getType
m
v
(VirtAddress)p(Type)i
_get
m
v
(VirtAddress)p
_puttype
m

(Value)v(VirtAddress)p(mytype)i
Free
m

(VirtAddress)p
SizeOf
M
i
(Data)v
'return the actual storage required for any data type
'objects must have a _write public function
FreeVirt
m

(VirtAddress)p
RealDataAddress
m
p
(VirtAddress)p
Lock
m


Unlock
m


VarPtr
m
v
(VirtAddress)p
text
m
s
(VirtAddress)p[(Indent)s(SetTree)b]
_next
m
v

TextTree
m
s
[(VirtAddress)p(Indent)i]
#mem

C
LastWriteLength
p
i

'The length of the last write
RootAddress
p
p

'The rootAddress of the actual memory
MemoryLength
p
l

'The length of the memory pool if originally provided
MemoryBlockSize
p
l

'Length of each block to allocate when out of space
RealPointers
r
b

'When this is set mem assumes its using real pointers not offset pointers, pointers must point to real data
'Indirection to objects and strings will not be used , just assumes its real pointers to data
'Root address should be set to zero if using actual memory or offset if still want to use the offset in shared memory
'Pointers need to point to the data portion of allocated buffers
_new
m

[(BaseAddress)p(UsingRealMemoryAddress)b(MemLength)l(MemBlockSize)l]
'This sets the usage style of the object
'first parameter should set the base of the shared memory area or 0 for Realmemory access
'Sets if this instance is for real memory, not base offset calculation
_SizeOf
M
i
(data)v
'return the actual storage required for any data type
'objects must have a _write public function
SetType
m

(Mempointer)p(rdType)i
_put
m

(data)v(Mempointer)p[(rdType)i(notype)b(RealPointers)b(AbsIndexed)b]
'Object entry point when used as array in user program
' Data - data as any data type
' MemPointer - Actual memory address to store the value
' rdType - override the datatype of the passed in variant
' notype - the memory location does not contain a memory variable type definition
' if fast value is 2 4 8 then the storage is there and created already
DataOffset
m
p
(Mempointer)p[(rdType)i(notype)b]
'This function returns the relative addr of the data portion of the memory location
'notype will always assume binary type and return the address of binary blob at the address
'The read type can override the normal value for the variable
_get
m
v
(Mempointer)p[(rdType)i(notype)b(RealPointers)b(AbsIndexed)b]
'Get variable from memory
'
'Mempointer - the location to get the data from
'rdType - the type of data to be read, this is an over ride for the stored data type or used when no datatype stored
'notype - the storgae location first has no data type specified
AddrData
m
p
(Mempointer)p[(rdType)i(notype)b]
'This function returns the address of the data portion of the memory location
'notype will always assume binary type and return the address of binary blob at the address
'The read type can override the normal value for the variable
AddrReal
m
p
(Mempointer)p
'AddrReal returns the Real memory address of the data,
'Most address used within this class are virtual addresses
'within the allocated shared memory block
ReadData
m

(mPointer)p(mFile)File;(DataLength)i[(rdType)i(notype)b]
'Load data from afile into virtual memory
'Address provided id the virtual memory offset
WriteData
m

(mPointer)p(mFile)File;(DataLength)i[(rdType)i(notype)b]
'Write a block of data from virtual memory
'address provided is virtual i.e. the offset with the allocated
'Shared memory block
DumpMem
M

(mPointer)p(IntLength)i[(Filename)s]
'a function which may be called to dump the content of any memory area to a file
'The default location if no name specified is the users desktop as dumpfile
DumpAllMem
m


'Dump all the memory for this mem object
#ptr

C
str
M
p
(Var)s
'This function returns a pointer to a strings content
'as for some reason gambas will not do a varptr of a string
'go figure...
'Also remember that strings in gambas are static,
'So you must get a new address everytime the string is altered
Array
M
p
(Var)o
'This function returns a pointer to the data portion of an array
'Be carefull using this as every array type has a gambas specific
'memory format, so understand that before using this
Object
M
p
(Var)o
'this function allocates memory blocks and creates a static copy of the
'object data to pass to a c function, or transmit via ssh
'This is very very slow slow.....
#shmMem

C
Version
p
s

Debug
p
b

varStore
v
ShmMemBlock

varMnge
v
ShmManage

MyVarMem
v
ShmVarStorage

VarStoreName
v
s

symStore
v
ShmMemBlock

vars
v
ShmSymbolTable

SymStoreName
v
s

Count
r
i

Max
r
i

Length
r
i

Key
r
s

Used
r
l

Available
r
l

DefaultDirectory
p
s

SyncMemFile
p
s

SyncVarFile
p
s

DataTypes
V
String[]

ForceDelete
M

(SharedName)s
'Remove the memory by force
_new
m

[(VarMemLength)l(MemName)s(MaxSymbols)i(LockTimeOut)f(Cleanup)b]
'Allocate the memory
_free
m


_property
m
b
.
_unknown
m
v
.
_get
m
v
(SymName)s.
_put
m

(value)v(SymName)s.
Free
m

(SymName)v
Sync
m

[(Symbol)s(filename)s]
'Read and write images and variables
SaveImage
m

[(filename)s]
SaveVar
m

(VarName)s[(filename)s]
End
m

[(filename)s]
copy
m

(SymbolName)s(NewName)s
Rename
m

(SymbolName)s(NewName)s[(force)b]
Restore
m
b
[(Symbol)s(filename)s]
LoadVar
m

(filename)s[(SymName)s]
LoadImage
m

[(filename)s(cleanload)b]
Merge
m
b
[(filename)s]
SetPath
m
s
(filePath)s[(defaultBaseName)s(defaultExtension)s]
VarPtr
m
v
(SymName)s
SizeOf
m
l
(value)v
_Print
m


Print
m


PrintAllInfo
m


PrintTree
m


WaitFor
m
b
(SymName)s[(Timeout)f]
WaitForValue
m
b
(SymName)s(value)v[(Timeout)f]
WaitValueChange
m
b
(SymName)s(value)v[(Timeout)f]
Notify
m

(SymName)s(NotifyObject)o[(NotifyFunction)s]
NotifyStop
m

(SymName)s
_next
m
v

Exist
m
b
(SymName)s
RealAddress
m
p
(VirtAddress)p
'Returns the actual Physical address after traslating the Virtual pointer
alloc
m
p
(Length)p
'Allocate a block of memory
Variables
m
String[]
[(filter)s]
'This Will return a table of variables in the format string[]
'Filtered by the provided pattern
VariableList
m
s

'This function returns a list of comma seperated variable names
'a list formated set
